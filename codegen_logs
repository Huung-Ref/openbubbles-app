[2024-05-11T19:31:31.075Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/main.rs:24] cli=Cli { verbose: false, command: Generate(GenerateCommandArgs { watch: false, primary: GenerateCommandArgsPrimary { config_file: None, rust_input: None, dart_output: None, c_output: None, duplicated_c_output: None, rust_root: None, rust_output: None, dart_entrypoint_class_name: None, dart_format_line_length: None, no_dart_enums_style: false, no_add_mod_to_lib: false, llvm_path: None, llvm_compiler_opts: None, dart_root: None, no_build_runner: false, extra_headers: None, no_web: false, no_deps_check: false, default_external_library_loader_web_prefix: None, no_dart3: false, full_dep: false, local: false, dump: None, dump_all: false } }) }
[2024-05-11T19:31:31.076Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/binary/commands_parser.rs:8] compute_codegen_config: mode=from_files_auto
[2024-05-11T19:31:31.076Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/config/config_parser.rs:45] Found config file flutter_rust_bridge.yaml
[2024-05-11T19:31:31.076Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/mod.rs:24] config=Config { base_dir: Some(""), rust_input: "rust/src/api/**/*.rs", dart_output: "lib/src/rust", c_output: None, duplicated_c_output: None, rust_root: None, rust_output: None, dart_entrypoint_class_name: None, dart_format_line_length: None, dart_enums_style: None, add_mod_to_lib: None, llvm_path: None, llvm_compiler_opts: None, dart_root: None, build_runner: None, extra_headers: None, web: None, deps_check: None, dart3: None, full_dep: None, local: None, default_external_library_loader_web_prefix: None, dump: None, dump_all: None } meta_config=MetaConfig { watch: false }
[2024-05-11T19:31:31.076Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/config/internal_config_parser.rs:42] InternalConfig.parse base_dir="/home/tae/Documents/GitHub/bb-app-restore"
[2024-05-11T19:31:32.144Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/mod.rs:27] internal_config=InternalConfig { controller: ControllerInternalConfig { watch: false, watching_paths: ["/home/tae/Documents/GitHub/bb-app-restore/rust/src"], exclude_paths: ["/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.io.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.web.rs"], max_count: None }, preparer: PreparerInternalConfig { dart_root: "/home/tae/Documents/GitHub/bb-app-restore", deps_check: true, needs_ffigen: false }, parser: ParserInternalConfig { rust_input_path_pack: RustInputPathPack { rust_input_paths: ["/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/api.rs"] }, rust_crate_dir: "/home/tae/Documents/GitHub/bb-app-restore/rust", force_codec_mode_pack: Some(CodecModePack { dart2rust: Pde, rust2dart: Pde }), default_stream_sink_codec: Sse, default_rust_opaque_codec: Moi }, generator: GeneratorInternalConfig { api_dart: GeneratorApiDartInternalConfig { dart_enums_style: true, dart3: true, dart_decl_base_output_path: "/home/tae/Documents/GitHub/bb-app-restore/lib/src/rust", dart_entrypoint_class_name: "RustLib" }, wire: GeneratorWireInternalConfig { dart: GeneratorWireDartInternalConfig { has_ffigen: false, web_enabled: true, llvm_path: ["/opt/homebrew/opt/llvm", "/usr/local/opt/llvm", "/usr/lib/llvm-9", "/usr/lib/llvm-10", "/usr/lib/llvm-11", "/usr/lib/llvm-12", "/usr/lib/llvm-13", "/usr/lib/llvm-14", "/usr/lib/", "/usr/lib64/", "C:/Program Files/llvm", "C:/msys64/mingw64"], llvm_compiler_opts: "", dart_root: "/home/tae/Documents/GitHub/bb-app-restore", extra_headers: "", dart_impl_output_path: TargetOrCommonMap { common: "/home/tae/Documents/GitHub/bb-app-restore/lib/src/rust/frb_generated.dart", io: "/home/tae/Documents/GitHub/bb-app-restore/lib/src/rust/frb_generated.io.dart", web: "/home/tae/Documents/GitHub/bb-app-restore/lib/src/rust/frb_generated.web.dart" }, dart_output_class_name_pack: DartOutputClassNamePack { entrypoint_class_name: "RustLib", api_class_name: "RustLibApi", api_impl_class_name: "RustLibApiImpl", api_impl_platform_class_name: "RustLibApiImplPlatform", wire_class_name: "RustLibWire", wasm_module_name: "RustLibWasmModule" }, default_external_library_loader: GeneratorWireDartDefaultExternalLibraryLoaderInternalConfig { stem: "rust_lib_bluebubbles", io_directory: "rust/target/release/", web_prefix: "pkg/" }, c_symbol_prefix: "frbgen_bluebubbles_" }, rust: GeneratorWireRustInternalConfig { rust_input_path_pack: RustInputPathPack { rust_input_paths: ["/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/api.rs"] }, rust_crate_dir: "/home/tae/Documents/GitHub/bb-app-restore/rust", web_enabled: true, rust_output_path: TargetOrCommonMap { common: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", io: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.io.rs", web: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.web.rs" }, c_symbol_prefix: "frbgen_bluebubbles_", has_ffigen: false, default_stream_sink_codec: Sse, default_rust_opaque_codec: Moi }, c: GeneratorWireCInternalConfig { enable: false, rust_crate_dir: "/home/tae/Documents/GitHub/bb-app-restore/rust", rust_output_path: TargetOrCommonMap { common: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", io: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.io.rs", web: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.web.rs" }, c_output_path: None, c_symbol_prefix: "frbgen_bluebubbles_" } } }, polisher: PolisherInternalConfig { duplicated_c_output_path: [], dart_format_line_length: 80, add_mod_to_lib: true, build_runner: true, web_enabled: true, dart_root: "/home/tae/Documents/GitHub/bb-app-restore", rust_crate_dir: "/home/tae/Documents/GitHub/bb-app-restore/rust", rust_output_path: TargetOrCommonMap { common: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", io: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.io.rs", web: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.web.rs" }, c_output_path: None, enable_auto_upgrade: true }, dumper: DumperInternalConfig { dump_contents: [], dump_directory: "/home/tae/Documents/GitHub/bb-app-restore/rust/target/frb_dump" } }
[2024-05-11T19:31:32.145Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:22] Guessing toolchain the runner is run into
[2024-05-11T19:31:32.155Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:129] execute command: bin=sh args="-c \"flutter\" \"--version\"" current_dir=None cmd="sh" "-c" "\"flutter\" \"--version\""
[2024-05-11T19:31:32.861Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:140] command="sh" "-c" "\"flutter\" \"--version\"" stdout=Flutter 3.19.4 • channel stable • https://github.com/flutter/flutter.git
Framework • revision 68bfaea224 (7 weeks ago) • 2024-03-20 15:36:31 -0700
Engine • revision a5c24f538d
Tools • Dart 3.3.2 • DevTools 2.31.1
 stderr=
[2024-05-11T19:31:32.862Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/reader.rs:22] read_rust_file rust_file_path="/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/api.rs" module=Some("api::api")
[2024-05-11T19:31:32.862Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/cargo_expand.rs:31] CachedCargoExpand execute manifest_dir= rust_crate_dir="/home/tae/Documents/GitHub/bb-app-restore/rust"
[2024-05-11T19:31:32.862Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/cargo_expand.rs:118] Running cargo expand in '"/home/tae/Documents/GitHub/bb-app-restore/rust"'
[2024-05-11T19:31:32.862Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:129] execute command: bin=cargo args="expand --lib --theme=none --ugly" current_dir=Some("/home/tae/Documents/GitHub/bb-app-restore/rust") cmd=cd "/home/tae/Documents/GitHub/bb-app-restore/rust" && RUSTFLAGS="--cfg frb_expand" "cargo" "expand" "--lib" "--theme=none" "--ugly"
[2024-05-11T19:31:35.585Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:140] command=cd "/home/tae/Documents/GitHub/bb-app-restore/rust" && RUSTFLAGS="--cfg frb_expand" "cargo" "expand" "--lib" "--theme=none" "--ugly" stdout=#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::sync::OnceLock;

use tokio::runtime::Runtime;
use uniffi::deps::log::info;


#[doc(hidden)]
pub struct UniFfiTag;
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_rust_lib_bluebubbles_uniffi_contract_version() -> u32 {
    26u32
}
#[doc = r" Export namespace metadata."]
#[doc = r""]
#[doc = r" See `uniffi_bindgen::macro_metadata` for how this is used."]
const UNIFFI_META_CONST_NAMESPACE_RUST_LIB_BLUEBUBBLES:
    ::uniffi::MetadataBuffer =
    ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::NAMESPACE).concat_str("rust_lib_bluebubbles").concat_str("rust_lib_bluebubbles");
#[doc(hidden)]
#[no_mangle]
pub static UNIFFI_META_NAMESPACE_RUST_LIB_BLUEBUBBLES:
    [u8; UNIFFI_META_CONST_NAMESPACE_RUST_LIB_BLUEBUBBLES.size] =
    UNIFFI_META_CONST_NAMESPACE_RUST_LIB_BLUEBUBBLES.into_array();
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_rust_lib_bluebubbles_rustbuffer_alloc(size: u64,
    call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_alloc(size, call_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rustbuffer_from_bytes(bytes:
        uniffi::ForeignBytes, call_status: &mut uniffi::RustCallStatus)
    -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_from_bytes(bytes, call_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rustbuffer_free(buf:
        uniffi::RustBuffer, call_status: &mut uniffi::RustCallStatus) {
    uniffi::ffi::uniffi_rustbuffer_free(buf, call_status);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rustbuffer_reserve(buf:
        uniffi::RustBuffer, additional: u64,
    call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_reserve(buf, additional, call_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_u8(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<u8,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_u8(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<u8, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_u8(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> u8 {
    ::uniffi::ffi::rust_future_complete::<u8,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_u8(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<u8, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_i8(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<i8,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_i8(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<i8, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_i8(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> i8 {
    ::uniffi::ffi::rust_future_complete::<i8,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_i8(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<i8, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_u16(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<u16,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_u16(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<u16, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_u16(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> u16 {
    ::uniffi::ffi::rust_future_complete::<u16,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_u16(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<u16, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_i16(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<i16,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_i16(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<i16, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_i16(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> i16 {
    ::uniffi::ffi::rust_future_complete::<i16,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_i16(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<i16, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_u32(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<u32,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_u32(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<u32, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_u32(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> u32 {
    ::uniffi::ffi::rust_future_complete::<u32,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_u32(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<u32, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_i32(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<i32,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_i32(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<i32, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_i32(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> i32 {
    ::uniffi::ffi::rust_future_complete::<i32,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_i32(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<i32, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_u64(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<u64,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_u64(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<u64, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_u64(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> u64 {
    ::uniffi::ffi::rust_future_complete::<u64,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_u64(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<u64, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_i64(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<i64,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_i64(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<i64, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_i64(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> i64 {
    ::uniffi::ffi::rust_future_complete::<i64,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_i64(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<i64, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_f32(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<f32,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_f32(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<f32, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_f32(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> f32 {
    ::uniffi::ffi::rust_future_complete::<f32,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_f32(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<f32, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_f64(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<f64,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_f64(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<f64, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_f64(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> f64 {
    ::uniffi::ffi::rust_future_complete::<f64,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_f64(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<f64, crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_pointer(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<*const ::std::ffi::c_void,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_pointer(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<*const ::std::ffi::c_void,
            crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_pointer(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus)
    -> *const ::std::ffi::c_void {
    ::uniffi::ffi::rust_future_complete::<*const ::std::ffi::c_void,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_pointer(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<*const ::std::ffi::c_void,
            crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_rust_buffer(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<::uniffi::RustBuffer,
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_rust_buffer(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<::uniffi::RustBuffer,
            crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_rust_buffer(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus)
    -> ::uniffi::RustBuffer {
    ::uniffi::ffi::rust_future_complete::<::uniffi::RustBuffer,
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_rust_buffer(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<::uniffi::RustBuffer,
            crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_poll_void(handle:
        ::uniffi::Handle, callback: ::uniffi::RustFutureContinuationCallback,
    data: u64) {
    ::uniffi::ffi::rust_future_poll::<(),
            crate::UniFfiTag>(handle, callback, data);
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_cancel_void(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_cancel::<(), crate::UniFfiTag>(handle)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_complete_void(handle:
        ::uniffi::Handle, out_status: &mut ::uniffi::RustCallStatus) -> () {
    ::uniffi::ffi::rust_future_complete::<(),
            crate::UniFfiTag>(handle, out_status)
}
#[allow(clippy :: missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_rust_lib_bluebubbles_rust_future_free_void(handle:
        ::uniffi::Handle) {
    ::uniffi::ffi::rust_future_free::<(), crate::UniFfiTag>(handle)
}
#[allow(missing_docs)]
#[doc(hidden)]
pub const fn uniffi_reexport_hack() {}
#[doc(hidden)]
#[macro_export]
macro_rules! uniffi_reexport_scaffolding {
    () =>
    {
        #[doc(hidden)] #[no_mangle] pub extern "C" fn
        rust_lib_bluebubbles_uniffi_reexport_hack()
        { $crate :: uniffi_reexport_hack() }
    } ;
}
#[allow(unused)]
#[doc(hidden)]
pub trait UniffiCustomTypeConverter {
    type Builtin;
    fn into_custom(val: Self::Builtin)
    -> uniffi::Result<Self>
    where
    Self: Sized;
    fn from_custom(obj: Self)
    -> Self::Builtin;
}

pub fn runtime() -> &'static tokio::runtime::Runtime {
    static RUNTIME: OnceLock<tokio::runtime::Runtime> = OnceLock::new();


    /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
    {
        let lvl = ::log::Level::Info;
        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api::log(format_args!("creating runner"),
                    lvl,
                    &("rust_lib_bluebubbles", "rust_lib_bluebubbles",
                            "src/lib.rs"), 11u32, ::log::__private_api::Option::None);
            }
    };
    RUNTIME.get_or_init(||
            tokio::runtime::Builder::new_multi_thread().worker_threads(1).thread_name("tokio-rustpush").enable_all().build().unwrap())
}
pub mod bbhwinfo {
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct HwInfo {
        #[prost(message, optional, tag = "1")]
        pub inner: ::core::option::Option<hw_info::InnerHwInfo>,
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        #[prost(int32, tag = "3")]
        pub protocol_version: i32,
        #[prost(string, tag = "4")]
        pub device_id: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub icloud_ua: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub aoskit_version: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for HwInfo {
        #[inline]
        fn clone(&self) -> HwInfo {
            HwInfo {
                inner: ::core::clone::Clone::clone(&self.inner),
                version: ::core::clone::Clone::clone(&self.version),
                protocol_version: ::core::clone::Clone::clone(&self.protocol_version),
                device_id: ::core::clone::Clone::clone(&self.device_id),
                icloud_ua: ::core::clone::Clone::clone(&self.icloud_ua),
                aoskit_version: ::core::clone::Clone::clone(&self.aoskit_version),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for HwInfo { }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for HwInfo {
        #[inline]
        fn eq(&self, other: &HwInfo) -> bool {
            self.inner == other.inner && self.version == other.version &&
                            self.protocol_version == other.protocol_version &&
                        self.device_id == other.device_id &&
                    self.icloud_ua == other.icloud_ua &&
                self.aoskit_version == other.aoskit_version
        }
    }
    impl ::prost::Message for HwInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B) where B: ::prost::bytes::BufMut {
            if let Some(ref msg) = self.inner {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
            if self.version != "" {
                    ::prost::encoding::string::encode(2u32, &self.version, buf);
                }
            if self.protocol_version != 0i32 {
                    ::prost::encoding::int32::encode(3u32,
                        &self.protocol_version, buf);
                }
            if self.device_id != "" {
                    ::prost::encoding::string::encode(4u32, &self.device_id,
                        buf);
                }
            if self.icloud_ua != "" {
                    ::prost::encoding::string::encode(5u32, &self.icloud_ua,
                        buf);
                }
            if self.aoskit_version != "" {
                    ::prost::encoding::string::encode(6u32,
                        &self.aoskit_version, buf);
                }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(&mut self, tag: u32,
            wire_type: ::prost::encoding::WireType, buf: &mut B,
            ctx: ::prost::encoding::DecodeContext)
            -> ::core::result::Result<(), ::prost::DecodeError> where
            B: ::prost::bytes::Buf {
            const STRUCT_NAME: &'static str = "HwInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.inner;
                    ::prost::encoding::message::merge(wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "inner"); error })
                }
                2u32 => {
                    let mut value = &mut self.version;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "version"); error })
                }
                3u32 => {
                    let mut value = &mut self.protocol_version;
                    ::prost::encoding::int32::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "protocol_version"); error })
                }
                4u32 => {
                    let mut value = &mut self.device_id;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "device_id"); error })
                }
                5u32 => {
                    let mut value = &mut self.icloud_ua;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "icloud_ua"); error })
                }
                6u32 => {
                    let mut value = &mut self.aoskit_version;
                    ::prost::encoding::string::merge(wire_type, value, buf,
                            ctx).map_err(|mut error|
                            { error.push(STRUCT_NAME, "aoskit_version"); error })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 +
                                    self.inner.as_ref().map_or(0,
                                        |msg| ::prost::encoding::message::encoded_len(1u32, msg)) +
                                if self.version != "" {
                                        ::prost::encoding::string::encoded_len(2u32, &self.version)
                                    } else { 0 } +
                            if self.protocol_version != 0i32 {
                                    ::prost::encoding::int32::encoded_len(3u32,
                                        &self.protocol_version)
                                } else { 0 } +
                        if self.device_id != "" {
                                ::prost::encoding::string::encoded_len(4u32,
                                    &self.device_id)
                            } else { 0 } +
                    if self.icloud_ua != "" {
                            ::prost::encoding::string::encoded_len(5u32,
                                &self.icloud_ua)
                        } else { 0 } +
                if self.aoskit_version != "" {
                        ::prost::encoding::string::encoded_len(6u32,
                            &self.aoskit_version)
                    } else { 0 }
        }
        fn clear(&mut self) {
            self.inner = ::core::option::Option::None;
            self.version.clear();
            self.protocol_version = 0i32;
            self.device_id.clear();
            self.icloud_ua.clear();
            self.aoskit_version.clear();
        }
    }
    impl ::core::default::Default for HwInfo {
        fn default() -> Self {
            HwInfo {
                inner: ::core::default::Default::default(),
                version: ::prost::alloc::string::String::new(),
                protocol_version: 0i32,
                device_id: ::prost::alloc::string::String::new(),
                icloud_ua: ::prost::alloc::string::String::new(),
                aoskit_version: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for HwInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("HwInfo");
            let builder =
                {
                    let wrapper = &self.inner;
                    builder.field("inner", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.version)
                        };
                    builder.field("version", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.protocol_version)
                        };
                    builder.field("protocol_version", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.device_id)
                        };
                    builder.field("device_id", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.icloud_ua)
                        };
                    builder.field("icloud_ua", &wrapper)
                };
            ;
            let builder =
                {
                    let wrapper =
                        {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T { v }
                            ScalarWrapper(&self.aoskit_version)
                        };
                    builder.field("aoskit_version", &wrapper)
                };
            ;
            builder.finish()
        }
    }
    /// Nested message and enum types in `HwInfo`.
    pub mod hw_info {
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct InnerHwInfo {
            #[prost(string, tag = "1")]
            pub product_name: ::prost::alloc::string::String,
            #[prost(bytes = "vec", tag = "2")]
            pub io_mac_address: ::prost::alloc::vec::Vec<u8>,
            #[prost(string, tag = "3")]
            pub platform_serial_number: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub platform_uuid: ::prost::alloc::string::String,
            #[prost(string, tag = "5")]
            pub root_disk_uuid: ::prost::alloc::string::String,
            #[prost(string, tag = "6")]
            pub board_id: ::prost::alloc::string::String,
            #[prost(string, tag = "7")]
            pub os_build_num: ::prost::alloc::string::String,
            #[prost(bytes = "vec", tag = "8")]
            pub platform_serial_number_enc: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "9")]
            pub platform_uuid_enc: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "10")]
            pub root_disk_uuid_enc: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "11")]
            pub rom: ::prost::alloc::vec::Vec<u8>,
            #[prost(bytes = "vec", tag = "12")]
            pub rom_enc: ::prost::alloc::vec::Vec<u8>,
            #[prost(string, tag = "13")]
            pub mlb: ::prost::alloc::string::String,
            #[prost(bytes = "vec", tag = "14")]
            pub mlb_enc: ::prost::alloc::vec::Vec<u8>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for InnerHwInfo {
            #[inline]
            fn clone(&self) -> InnerHwInfo {
                InnerHwInfo {
                    product_name: ::core::clone::Clone::clone(&self.product_name),
                    io_mac_address: ::core::clone::Clone::clone(&self.io_mac_address),
                    platform_serial_number: ::core::clone::Clone::clone(&self.platform_serial_number),
                    platform_uuid: ::core::clone::Clone::clone(&self.platform_uuid),
                    root_disk_uuid: ::core::clone::Clone::clone(&self.root_disk_uuid),
                    board_id: ::core::clone::Clone::clone(&self.board_id),
                    os_build_num: ::core::clone::Clone::clone(&self.os_build_num),
                    platform_serial_number_enc: ::core::clone::Clone::clone(&self.platform_serial_number_enc),
                    platform_uuid_enc: ::core::clone::Clone::clone(&self.platform_uuid_enc),
                    root_disk_uuid_enc: ::core::clone::Clone::clone(&self.root_disk_uuid_enc),
                    rom: ::core::clone::Clone::clone(&self.rom),
                    rom_enc: ::core::clone::Clone::clone(&self.rom_enc),
                    mlb: ::core::clone::Clone::clone(&self.mlb),
                    mlb_enc: ::core::clone::Clone::clone(&self.mlb_enc),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for InnerHwInfo { }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for InnerHwInfo {
            #[inline]
            fn eq(&self, other: &InnerHwInfo) -> bool {
                self.product_name == other.product_name &&
                                                                    self.io_mac_address == other.io_mac_address &&
                                                                self.platform_serial_number == other.platform_serial_number
                                                            && self.platform_uuid == other.platform_uuid &&
                                                        self.root_disk_uuid == other.root_disk_uuid &&
                                                    self.board_id == other.board_id &&
                                                self.os_build_num == other.os_build_num &&
                                            self.platform_serial_number_enc ==
                                                other.platform_serial_number_enc &&
                                        self.platform_uuid_enc == other.platform_uuid_enc &&
                                    self.root_disk_uuid_enc == other.root_disk_uuid_enc &&
                                self.rom == other.rom && self.rom_enc == other.rom_enc &&
                        self.mlb == other.mlb && self.mlb_enc == other.mlb_enc
            }
        }
        impl ::prost::Message for InnerHwInfo {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B) where
                B: ::prost::bytes::BufMut {
                if self.product_name != "" {
                        ::prost::encoding::string::encode(1u32, &self.product_name,
                            buf);
                    }
                if self.io_mac_address != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.io_mac_address,
                            buf);
                    }
                if self.platform_serial_number != "" {
                        ::prost::encoding::string::encode(3u32,
                            &self.platform_serial_number, buf);
                    }
                if self.platform_uuid != "" {
                        ::prost::encoding::string::encode(4u32, &self.platform_uuid,
                            buf);
                    }
                if self.root_disk_uuid != "" {
                        ::prost::encoding::string::encode(5u32,
                            &self.root_disk_uuid, buf);
                    }
                if self.board_id != "" {
                        ::prost::encoding::string::encode(6u32, &self.board_id,
                            buf);
                    }
                if self.os_build_num != "" {
                        ::prost::encoding::string::encode(7u32, &self.os_build_num,
                            buf);
                    }
                if self.platform_serial_number_enc != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(8u32,
                            &self.platform_serial_number_enc, buf);
                    }
                if self.platform_uuid_enc != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(9u32,
                            &self.platform_uuid_enc, buf);
                    }
                if self.root_disk_uuid_enc != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(10u32,
                            &self.root_disk_uuid_enc, buf);
                    }
                if self.rom != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(11u32, &self.rom, buf);
                    }
                if self.rom_enc != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(12u32, &self.rom_enc, buf);
                    }
                if self.mlb != "" {
                        ::prost::encoding::string::encode(13u32, &self.mlb, buf);
                    }
                if self.mlb_enc != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(14u32, &self.mlb_enc, buf);
                    }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(&mut self, tag: u32,
                wire_type: ::prost::encoding::WireType, buf: &mut B,
                ctx: ::prost::encoding::DecodeContext)
                -> ::core::result::Result<(), ::prost::DecodeError> where
                B: ::prost::bytes::Buf {
                const STRUCT_NAME: &'static str = "InnerHwInfo";
                match tag {
                    1u32 => {
                        let mut value = &mut self.product_name;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "product_name"); error })
                    }
                    2u32 => {
                        let mut value = &mut self.io_mac_address;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "io_mac_address"); error })
                    }
                    3u32 => {
                        let mut value = &mut self.platform_serial_number;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                {
                                    error.push(STRUCT_NAME, "platform_serial_number");
                                    error
                                })
                    }
                    4u32 => {
                        let mut value = &mut self.platform_uuid;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "platform_uuid"); error })
                    }
                    5u32 => {
                        let mut value = &mut self.root_disk_uuid;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "root_disk_uuid"); error })
                    }
                    6u32 => {
                        let mut value = &mut self.board_id;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "board_id"); error })
                    }
                    7u32 => {
                        let mut value = &mut self.os_build_num;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "os_build_num"); error })
                    }
                    8u32 => {
                        let mut value = &mut self.platform_serial_number_enc;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                {
                                    error.push(STRUCT_NAME, "platform_serial_number_enc");
                                    error
                                })
                    }
                    9u32 => {
                        let mut value = &mut self.platform_uuid_enc;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "platform_uuid_enc"); error })
                    }
                    10u32 => {
                        let mut value = &mut self.root_disk_uuid_enc;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "root_disk_uuid_enc"); error })
                    }
                    11u32 => {
                        let mut value = &mut self.rom;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "rom"); error })
                    }
                    12u32 => {
                        let mut value = &mut self.rom_enc;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "rom_enc"); error })
                    }
                    13u32 => {
                        let mut value = &mut self.mlb;
                        ::prost::encoding::string::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "mlb"); error })
                    }
                    14u32 => {
                        let mut value = &mut self.mlb_enc;
                        ::prost::encoding::bytes::merge(wire_type, value, buf,
                                ctx).map_err(|mut error|
                                { error.push(STRUCT_NAME, "mlb_enc"); error })
                    }
                    _ =>
                        ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 +
                                                                        if self.product_name != "" {
                                                                                ::prost::encoding::string::encoded_len(1u32,
                                                                                    &self.product_name)
                                                                            } else { 0 } +
                                                                    if self.io_mac_address != b"" as &[u8] {
                                                                            ::prost::encoding::bytes::encoded_len(2u32,
                                                                                &self.io_mac_address)
                                                                        } else { 0 } +
                                                                if self.platform_serial_number != "" {
                                                                        ::prost::encoding::string::encoded_len(3u32,
                                                                            &self.platform_serial_number)
                                                                    } else { 0 } +
                                                            if self.platform_uuid != "" {
                                                                    ::prost::encoding::string::encoded_len(4u32,
                                                                        &self.platform_uuid)
                                                                } else { 0 } +
                                                        if self.root_disk_uuid != "" {
                                                                ::prost::encoding::string::encoded_len(5u32,
                                                                    &self.root_disk_uuid)
                                                            } else { 0 } +
                                                    if self.board_id != "" {
                                                            ::prost::encoding::string::encoded_len(6u32, &self.board_id)
                                                        } else { 0 } +
                                                if self.os_build_num != "" {
                                                        ::prost::encoding::string::encoded_len(7u32,
                                                            &self.os_build_num)
                                                    } else { 0 } +
                                            if self.platform_serial_number_enc != b"" as &[u8] {
                                                    ::prost::encoding::bytes::encoded_len(8u32,
                                                        &self.platform_serial_number_enc)
                                                } else { 0 } +
                                        if self.platform_uuid_enc != b"" as &[u8] {
                                                ::prost::encoding::bytes::encoded_len(9u32,
                                                    &self.platform_uuid_enc)
                                            } else { 0 } +
                                    if self.root_disk_uuid_enc != b"" as &[u8] {
                                            ::prost::encoding::bytes::encoded_len(10u32,
                                                &self.root_disk_uuid_enc)
                                        } else { 0 } +
                                if self.rom != b"" as &[u8] {
                                        ::prost::encoding::bytes::encoded_len(11u32, &self.rom)
                                    } else { 0 } +
                            if self.rom_enc != b"" as &[u8] {
                                    ::prost::encoding::bytes::encoded_len(12u32, &self.rom_enc)
                                } else { 0 } +
                        if self.mlb != "" {
                                ::prost::encoding::string::encoded_len(13u32, &self.mlb)
                            } else { 0 } +
                    if self.mlb_enc != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(14u32, &self.mlb_enc)
                        } else { 0 }
            }
            fn clear(&mut self) {
                self.product_name.clear();
                self.io_mac_address.clear();
                self.platform_serial_number.clear();
                self.platform_uuid.clear();
                self.root_disk_uuid.clear();
                self.board_id.clear();
                self.os_build_num.clear();
                self.platform_serial_number_enc.clear();
                self.platform_uuid_enc.clear();
                self.root_disk_uuid_enc.clear();
                self.rom.clear();
                self.rom_enc.clear();
                self.mlb.clear();
                self.mlb_enc.clear();
            }
        }
        impl ::core::default::Default for InnerHwInfo {
            fn default() -> Self {
                InnerHwInfo {
                    product_name: ::prost::alloc::string::String::new(),
                    io_mac_address: ::core::default::Default::default(),
                    platform_serial_number: ::prost::alloc::string::String::new(),
                    platform_uuid: ::prost::alloc::string::String::new(),
                    root_disk_uuid: ::prost::alloc::string::String::new(),
                    board_id: ::prost::alloc::string::String::new(),
                    os_build_num: ::prost::alloc::string::String::new(),
                    platform_serial_number_enc: ::core::default::Default::default(),
                    platform_uuid_enc: ::core::default::Default::default(),
                    root_disk_uuid_enc: ::core::default::Default::default(),
                    rom: ::core::default::Default::default(),
                    rom_enc: ::core::default::Default::default(),
                    mlb: ::prost::alloc::string::String::new(),
                    mlb_enc: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for InnerHwInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                let mut builder = f.debug_struct("InnerHwInfo");
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.product_name)
                            };
                        builder.field("product_name", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.io_mac_address)
                            };
                        builder.field("io_mac_address", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.platform_serial_number)
                            };
                        builder.field("platform_serial_number", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.platform_uuid)
                            };
                        builder.field("platform_uuid", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.root_disk_uuid)
                            };
                        builder.field("root_disk_uuid", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.board_id)
                            };
                        builder.field("board_id", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.os_build_num)
                            };
                        builder.field("os_build_num", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.platform_serial_number_enc)
                            };
                        builder.field("platform_serial_number_enc", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.platform_uuid_enc)
                            };
                        builder.field("platform_uuid_enc", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.root_disk_uuid_enc)
                            };
                        builder.field("root_disk_uuid_enc", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.rom)
                            };
                        builder.field("rom", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.rom_enc)
                            };
                        builder.field("rom_enc", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.mlb)
                            };
                        builder.field("mlb", &wrapper)
                    };
                ;
                let builder =
                    {
                        let wrapper =
                            {
                                #[allow(non_snake_case)]
                                fn ScalarWrapper<T>(v: T) -> T { v }
                                ScalarWrapper(&self.mlb_enc)
                            };
                        builder.field("mlb_enc", &wrapper)
                    };
                ;
                builder.finish()
            }
        }
    }
}
mod native {
    use std::{fmt::Debug, sync::{Arc, RwLock}};
    use tokio::runtime::{Handle, Runtime};
    use uniffi::deps::log::info;
    use crate::{
        api::api::{
            get_phase, new_push_state, recv_wait, InnerPushState, PollResult,
            PushState, RegistrationPhase,
        },
        frb_generated::FLUTTER_RUST_BRIDGE_HANDLER, runtime,
    };
    pub trait MsgReceiver: Send + Sync + Debug {
        fn receieved_msg(&self, msg: u64);
        fn native_ready(&self, is_ready: bool, state: Arc<NativePushState>);
    }
    const UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_INTERFACE_MSGRECEIVER:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::CALLBACK_TRAIT_INTERFACE).concat_str("rust_lib_bluebubbles").concat_str("MsgReceiver").concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static UNIFFI_META_RUST_LIB_BLUEBUBBLES_INTERFACE_MSGRECEIVER:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_INTERFACE_MSGRECEIVER.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_INTERFACE_MSGRECEIVER.into_array();
    #[doc(hidden)]
    #[no_mangle]
    #[doc = r" Clone a pointer to this object type"]
    #[doc = r""]
    #[doc =
    r" Safety: Only pass pointers returned by a UniFFI call.  Do not pass pointers that were"]
    #[doc = r" passed to the free function."]
    pub unsafe extern "C" fn uniffi_rust_lib_bluebubbles_fn_clone_msgreceiver(ptr:
            *const ::std::ffi::c_void,
        call_status: &mut ::uniffi::RustCallStatus)
        -> *const ::std::ffi::c_void {
        uniffi::rust_call(call_status,
            ||
                {
                    let ptr = ptr as *mut std::sync::Arc<dyn MsgReceiver>;
                    let arc = unsafe { ::std::sync::Arc::clone(&*ptr) };
                    Ok(::std::boxed::Box::into_raw(::std::boxed::Box::new(arc))
                            as *const ::std::ffi::c_void)
                })
    }
    #[doc(hidden)]
    #[no_mangle]
    #[doc = r" Free a pointer to this object type"]
    #[doc = r""]
    #[doc =
    r" Safety: Only pass pointers returned by a UniFFI call.  Do not pass pointers that were"]
    #[doc = r" passed to the free function."]
    #[doc = r""]
    #[doc =
    r" Note: clippy doesn't complain about this being unsafe, but it definitely is since it"]
    #[doc = r" calls `Box::from_raw`."]
    pub unsafe extern "C" fn uniffi_rust_lib_bluebubbles_fn_free_msgreceiver(ptr:
            *const ::std::ffi::c_void,
        call_status: &mut ::uniffi::RustCallStatus) {
        uniffi::rust_call(call_status,
            ||
                {
                    if !!ptr.is_null() {
                            ::core::panicking::panic("assertion failed: !ptr.is_null()")
                        };
                    drop(unsafe {
                            ::std::boxed::Box::from_raw(ptr as
                                    *mut std::sync::Arc<dyn MsgReceiver>)
                        });
                    Ok(())
                });
    }
    struct UniFfiTraitVtableMsgReceiver {
        receieved_msg: extern "C" fn(uniffi_handle: u64,
            msg: <u64 as ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
            uniffi_out_return:
                &mut <() as
                ::uniffi::LiftReturn<crate::UniFfiTag>>::ReturnType,
            uniffi_out_call_status: &mut ::uniffi::RustCallStatus),
        native_ready: extern "C" fn(uniffi_handle: u64,
            is_ready: <bool as ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
            state:
                <Arc<NativePushState> as
                ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
            uniffi_out_return:
                &mut <() as
                ::uniffi::LiftReturn<crate::UniFfiTag>>::ReturnType,
            uniffi_out_call_status: &mut ::uniffi::RustCallStatus),
        uniffi_free: extern "C" fn(handle: u64),
    }
    static UNIFFI_TRAIT_CELL_MSGRECEIVER:
        ::uniffi::UniffiForeignPointerCell<UniFfiTraitVtableMsgReceiver> =
        ::uniffi::UniffiForeignPointerCell::<UniFfiTraitVtableMsgReceiver>::new();
    #[no_mangle]
    extern "C" fn uniffi_rust_lib_bluebubbles_fn_init_callback_vtable_msgreceiver(vtable:
            ::std::ptr::NonNull<UniFfiTraitVtableMsgReceiver>) {
        UNIFFI_TRAIT_CELL_MSGRECEIVER.set(vtable);
    }
    struct UniFFICallbackHandlerMsgReceiver {
        handle: u64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UniFFICallbackHandlerMsgReceiver {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f,
                "UniFFICallbackHandlerMsgReceiver", "handle", &&self.handle)
        }
    }
    impl UniFFICallbackHandlerMsgReceiver {
        fn new(handle: u64) -> Self { Self { handle } }
    }
    const _: fn() =
        ||
            {
                fn assert_impl_all<T: ?Sized + ::core::marker::Send>() {}
                assert_impl_all::<UniFFICallbackHandlerMsgReceiver>();
            };
    impl MsgReceiver for UniFFICallbackHandlerMsgReceiver {
        fn receieved_msg(&self, msg: u64) -> () {
            let vtable = UNIFFI_TRAIT_CELL_MSGRECEIVER.get();
            let mut uniffi_call_status = ::uniffi::RustCallStatus::new();
            let mut uniffi_return_value:
                    <() as ::uniffi::LiftReturn<crate::UniFfiTag>>::ReturnType =
                ::uniffi::FfiDefault::ffi_default();
            (vtable.receieved_msg)(self.handle,
                <u64 as ::uniffi::Lower<crate::UniFfiTag>>::lower(msg),
                &mut uniffi_return_value, &mut uniffi_call_status);
            <() as
                    ::uniffi::LiftReturn<crate::UniFfiTag>>::lift_foreign_return(uniffi_return_value,
                uniffi_call_status)
        }
        fn native_ready(&self, is_ready: bool, state: Arc<NativePushState>)
            -> () {
            let vtable = UNIFFI_TRAIT_CELL_MSGRECEIVER.get();
            let mut uniffi_call_status = ::uniffi::RustCallStatus::new();
            let mut uniffi_return_value:
                    <() as ::uniffi::LiftReturn<crate::UniFfiTag>>::ReturnType =
                ::uniffi::FfiDefault::ffi_default();
            (vtable.native_ready)(self.handle,
                <bool as ::uniffi::Lower<crate::UniFfiTag>>::lower(is_ready),
                <Arc<NativePushState> as
                        ::uniffi::Lower<crate::UniFfiTag>>::lower(state),
                &mut uniffi_return_value, &mut uniffi_call_status);
            <() as
                    ::uniffi::LiftReturn<crate::UniFfiTag>>::lift_foreign_return(uniffi_return_value,
                uniffi_call_status)
        }
    }
    impl ::std::ops::Drop for UniFFICallbackHandlerMsgReceiver {
        fn drop(&mut self) {
            let vtable = UNIFFI_TRAIT_CELL_MSGRECEIVER.get();
            (vtable.uniffi_free)(self.handle);
        }
    }
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_fn_method_msgreceiver_receieved_msg(uniffi_self_lowered:
            <::std::sync::Arc<dyn MsgReceiver> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        msg: <u64 as ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        call_status: &mut ::uniffi::RustCallStatus)
        -> <() as ::uniffi::LowerReturn<crate::UniFfiTag>>::ReturnType {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("receieved_msg"),
                        lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 8u32,
                        ::log::__private_api::Option::None);
                }
        };
        let uniffi_lift_args =
            move ||
                Ok((match {
                                let boxed_foreign_arc =
                                    unsafe {
                                        Box::from_raw(uniffi_self_lowered as
                                                *mut ::std::sync::Arc<dyn MsgReceiver>)
                                    };
                                Ok(*boxed_foreign_arc)
                            } {
                            Ok(v) => v,
                            Err(e) => return Err(("self", e)),
                        },
                        match <u64 as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(msg) {
                            Ok(v) => v,
                            Err(e) => return Err(("msg", e)),
                        }));
        ::uniffi::rust_call(call_status,
            ||
                {
                    <() as
                            ::uniffi::LowerReturn<crate::UniFfiTag>>::lower_return(match uniffi_lift_args()
                            {
                            Ok(uniffi_args) => {
                                let uniffi_result =
                                    uniffi_args.0.receieved_msg(uniffi_args.1);
                                uniffi_result
                            }
                            Err((arg_name, anyhow_error)) => {
                                <() as
                                        ::uniffi::LowerReturn<crate::UniFfiTag>>::handle_failed_lift(arg_name,
                                    anyhow_error)
                            }
                        })
                })
    }
    const
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_RECEIEVED_MSG:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::TRAIT_METHOD).concat_str("rust_lib_bluebubbles").concat_str("MsgReceiver").concat_u32(0u32).concat_str("receieved_msg").concat_bool(false).concat_value(1u8).concat_str("msg").concat(<u64
                            as
                            ::uniffi::Lift<crate::UniFfiTag>>::TYPE_ID_META).concat_bool(false).concat(<()
                    as
                    ::uniffi::LowerReturn<crate::UniFfiTag>>::TYPE_ID_META).concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static
        UNIFFI_META_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_RECEIEVED_MSG:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_RECEIEVED_MSG.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_RECEIEVED_MSG.into_array();
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_checksum_method_msgreceiver_receieved_msg()
        -> u16 {
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_RECEIEVED_MSG.checksum()
    }
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_fn_method_msgreceiver_native_ready(uniffi_self_lowered:
            <::std::sync::Arc<dyn MsgReceiver> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        is_ready: <bool as ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        state:
            <Arc<NativePushState> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        call_status: &mut ::uniffi::RustCallStatus)
        -> <() as ::uniffi::LowerReturn<crate::UniFfiTag>>::ReturnType {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("native_ready"), lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 8u32,
                        ::log::__private_api::Option::None);
                }
        };
        let uniffi_lift_args =
            move ||
                Ok((match {
                                let boxed_foreign_arc =
                                    unsafe {
                                        Box::from_raw(uniffi_self_lowered as
                                                *mut ::std::sync::Arc<dyn MsgReceiver>)
                                    };
                                Ok(*boxed_foreign_arc)
                            } {
                            Ok(v) => v,
                            Err(e) => return Err(("self", e)),
                        },
                        match <bool as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(is_ready) {
                            Ok(v) => v,
                            Err(e) => return Err(("is_ready", e)),
                        },
                        match <Arc<NativePushState> as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(state) {
                            Ok(v) => v,
                            Err(e) => return Err(("state", e)),
                        }));
        ::uniffi::rust_call(call_status,
            ||
                {
                    <() as
                            ::uniffi::LowerReturn<crate::UniFfiTag>>::lower_return(match uniffi_lift_args()
                            {
                            Ok(uniffi_args) => {
                                let uniffi_result =
                                    uniffi_args.0.native_ready(uniffi_args.1, uniffi_args.2);
                                uniffi_result
                            }
                            Err((arg_name, anyhow_error)) => {
                                <() as
                                        ::uniffi::LowerReturn<crate::UniFfiTag>>::handle_failed_lift(arg_name,
                                    anyhow_error)
                            }
                        })
                })
    }
    const
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_NATIVE_READY:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::TRAIT_METHOD).concat_str("rust_lib_bluebubbles").concat_str("MsgReceiver").concat_u32(1u32).concat_str("native_ready").concat_bool(false).concat_value(2u8).concat_str("is_ready").concat(<bool
                                        as
                                        ::uniffi::Lift<crate::UniFfiTag>>::TYPE_ID_META).concat_bool(false).concat_str("state").concat(<Arc<NativePushState>
                            as
                            ::uniffi::Lift<crate::UniFfiTag>>::TYPE_ID_META).concat_bool(false).concat(<()
                    as
                    ::uniffi::LowerReturn<crate::UniFfiTag>>::TYPE_ID_META).concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static
        UNIFFI_META_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_NATIVE_READY:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_NATIVE_READY.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_NATIVE_READY.into_array();
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_checksum_method_msgreceiver_native_ready()
        -> u16 {
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_MSGRECEIVER_NATIVE_READY.checksum()
    }
    const _: fn() =
        ||
            {
                fn assert_impl_all<T: ?Sized + ::core::marker::Sync +
                    ::core::marker::Send>() {}
                assert_impl_all::<dyn MsgReceiver>();
            };
    unsafe impl<T> ::uniffi::FfiConverterArc<T> for dyn MsgReceiver {
        type FfiType = *const ::std::os::raw::c_void;
        fn lower(obj: ::std::sync::Arc<Self>) -> Self::FfiType {
            ::std::boxed::Box::into_raw(::std::boxed::Box::new(obj)) as
                *const ::std::os::raw::c_void
        }
        fn try_lift(v: Self::FfiType)
            -> ::uniffi::deps::anyhow::Result<::std::sync::Arc<Self>> {
            Ok(::std::sync::Arc::new(<UniFFICallbackHandlerMsgReceiver>::new(v
                            as u64)))
        }
        fn write(obj: ::std::sync::Arc<Self>, buf: &mut Vec<u8>) {
            #[allow(unknown_lints, eq_op)]
            const _:
                [(); 0 -
                    !{
                                const ASSERT: bool =
                                    ::std::mem::size_of::<*const ::std::ffi::c_void>() <= 8;
                                ASSERT
                            } as usize] =
                [];
            ::uniffi::deps::bytes::BufMut::put_u64(buf,
                <Self as
                            ::uniffi::FfiConverterArc<crate::UniFfiTag>>::lower(obj) as
                    u64);
        }
        fn try_read(buf: &mut &[u8])
            -> ::uniffi::Result<::std::sync::Arc<Self>> {
            #[allow(unknown_lints, eq_op)]
            const _:
                [(); 0 -
                    !{
                                const ASSERT: bool =
                                    ::std::mem::size_of::<*const ::std::ffi::c_void>() <= 8;
                                ASSERT
                            } as usize] =
                [];
            ::uniffi::check_remaining(buf, 8)?;
            <Self as
                    ::uniffi::FfiConverterArc<crate::UniFfiTag>>::try_lift(::uniffi::deps::bytes::Buf::get_u64(buf)
                    as Self::FfiType)
        }
        const TYPE_ID_META: ::uniffi::MetadataBuffer =
            ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::TYPE_CALLBACK_TRAIT_INTERFACE).concat_str("rust_lib_bluebubbles").concat_str("MsgReceiver");
    }
    unsafe impl<T> ::uniffi::LiftRef<T> for dyn MsgReceiver {
        type LiftType = ::std::sync::Arc<dyn MsgReceiver>;
    }
    pub struct NativePushState {
        state: Arc<PushState>,
    }
    #[doc(hidden)]
    #[no_mangle]
    pub unsafe extern "C" fn uniffi_rust_lib_bluebubbles_fn_clone_nativepushstate(ptr:
            *const ::std::ffi::c_void,
        call_status: &mut ::uniffi::RustCallStatus)
        -> *const ::std::ffi::c_void {
        uniffi::rust_call(call_status,
            ||
                {
                    unsafe { ::std::sync::Arc::increment_strong_count(ptr) };
                    Ok(ptr)
                })
    }
    #[doc(hidden)]
    #[no_mangle]
    pub unsafe extern "C" fn uniffi_rust_lib_bluebubbles_fn_free_nativepushstate(ptr:
            *const ::std::ffi::c_void,
        call_status: &mut ::uniffi::RustCallStatus) {
        uniffi::rust_call(call_status,
            ||
                {
                    if !!ptr.is_null() {
                            ::core::panicking::panic("assertion failed: !ptr.is_null()")
                        };
                    let ptr = ptr.cast::<NativePushState>();
                    unsafe { ::std::sync::Arc::decrement_strong_count(ptr); }
                    Ok(())
                });
    }
    const _: fn() =
        ||
            {
                fn assert_impl_all<T: ?Sized + ::core::marker::Sync +
                    ::core::marker::Send>() {}
                assert_impl_all::<NativePushState>();
            };
    #[doc(hidden)]
    #[automatically_derived]
    #[doc =
    r" Support for passing reference-counted shared objects via the FFI."]
    #[doc = r""]
    #[doc =
    r" To avoid dealing with complex lifetime semantics over the FFI, any data passed"]
    #[doc =
    r" by reference must be encapsulated in an `Arc`, and must be safe to share"]
    #[doc = r" across threads."]
    unsafe impl<T> ::uniffi::FfiConverterArc<T> for NativePushState {
        type FfiType = *const ::std::os::raw::c_void;
        #[doc =
        r" When lowering, we have an owned `Arc` and we transfer that ownership"]
        #[doc =
        r#" to the foreign-language code, "leaking" it out of Rust's ownership system"#]
        #[doc =
        r" as a raw pointer. This works safely because we have unique ownership of `self`."]
        #[doc =
        r" The foreign-language code is responsible for freeing this by calling the"]
        #[doc =
        r" `ffi_object_free` FFI function provided by the corresponding UniFFI type."]
        #[doc = r""]
        #[doc =
        r" Safety: when freeing the resulting pointer, the foreign-language code must"]
        #[doc =
        r" call the destructor function specific to the type `T`. Calling the destructor"]
        #[doc = r" function for other types may lead to undefined behaviour."]
        fn lower(obj: ::std::sync::Arc<Self>) -> Self::FfiType {
            ::std::sync::Arc::into_raw(obj) as Self::FfiType
        }
        #[doc =
        r" When lifting, we receive an owned `Arc` that the foreign language code cloned."]
        fn try_lift(v: Self::FfiType)
            -> ::uniffi::Result<::std::sync::Arc<Self>> {
            let v = v as *const NativePushState;
            Ok(unsafe { ::std::sync::Arc::<Self>::from_raw(v) })
        }
        #[doc =
        r" When writing as a field of a complex structure, make a clone and transfer ownership"]
        #[doc =
        r" of it to the foreign-language code by writing its pointer into the buffer."]
        #[doc =
        r" The foreign-language code is responsible for freeing this by calling the"]
        #[doc =
        r" `ffi_object_free` FFI function provided by the corresponding UniFFI type."]
        #[doc = r""]
        #[doc =
        r" Safety: when freeing the resulting pointer, the foreign-language code must"]
        #[doc =
        r" call the destructor function specific to the type `T`. Calling the destructor"]
        #[doc = r" function for other types may lead to undefined behaviour."]
        fn write(obj: ::std::sync::Arc<Self>, buf: &mut Vec<u8>) {
            #[allow(unknown_lints, eq_op)]
            const _:
                [(); 0 -
                    !{
                                const ASSERT: bool =
                                    ::std::mem::size_of::<*const ::std::ffi::c_void>() <= 8;
                                ASSERT
                            } as usize] =
                [];
            ::uniffi::deps::bytes::BufMut::put_u64(buf,
                <Self as
                            ::uniffi::FfiConverterArc<crate::UniFfiTag>>::lower(obj) as
                    u64);
        }
        #[doc =
        r#" When reading as a field of a complex structure, we receive a "borrow" of the `Arc`"#]
        #[doc =
        r" that is owned by the foreign-language code, and make a clone for our own use."]
        #[doc = r""]
        #[doc =
        r" Safety: the buffer must contain a pointer previously obtained by calling"]
        #[doc = r" the `lower()` or `write()` method of this impl."]
        fn try_read(buf: &mut &[u8])
            -> ::uniffi::Result<::std::sync::Arc<Self>> {
            #[allow(unknown_lints, eq_op)]
            const _:
                [(); 0 -
                    !{
                                const ASSERT: bool =
                                    ::std::mem::size_of::<*const ::std::ffi::c_void>() <= 8;
                                ASSERT
                            } as usize] =
                [];
            ::uniffi::check_remaining(buf, 8)?;
            <Self as
                    ::uniffi::FfiConverterArc<crate::UniFfiTag>>::try_lift(::uniffi::deps::bytes::Buf::get_u64(buf)
                    as Self::FfiType)
        }
        const TYPE_ID_META: ::uniffi::MetadataBuffer =
            ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::TYPE_INTERFACE).concat_str("rust_lib_bluebubbles").concat_str("NativePushState");
    }
    unsafe impl<T> ::uniffi::LowerReturn<T> for NativePushState {
        type ReturnType =
            <Self as ::uniffi::FfiConverterArc<crate::UniFfiTag>>::FfiType;
        fn lower_return(obj: Self)
            -> ::std::result::Result<Self::ReturnType, ::uniffi::RustBuffer> {
            Ok(<Self as
                        ::uniffi::FfiConverterArc<crate::UniFfiTag>>::lower(::std::sync::Arc::new(obj)))
        }
        const TYPE_ID_META: ::uniffi::MetadataBuffer =
            <Self as
                ::uniffi::FfiConverterArc<crate::UniFfiTag>>::TYPE_ID_META;
    }
    unsafe impl<T> ::uniffi::LiftRef<T> for NativePushState {
        type LiftType = ::std::sync::Arc<Self>;
    }
    const UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_INTERFACE_NATIVEPUSHSTATE:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::INTERFACE).concat_str("rust_lib_bluebubbles").concat_str("NativePushState").concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static UNIFFI_META_RUST_LIB_BLUEBUBBLES_INTERFACE_NATIVEPUSHSTATE:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_INTERFACE_NATIVEPUSHSTATE.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_INTERFACE_NATIVEPUSHSTATE.into_array();
    pub fn init_native(dir: String, handler: Arc<dyn MsgReceiver>) {
        {
            let lvl = ::log::Level::Info;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("rpljslf start"),
                        lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 23u32,
                        ::log::__private_api::Option::None);
                }
        };
        runtime().spawn(async move
                {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("rpljslf initting"),
                                lvl,
                                &("rust_lib_bluebubbles::native",
                                        "rust_lib_bluebubbles::native", "src/native.rs"), 25u32,
                                ::log::__private_api::Option::None);
                        }
                };
                let state =
                    Arc::new(NativePushState {
                            state: new_push_state(dir).await.unwrap(),
                        });
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("rpljslf raed"), lvl,
                                &("rust_lib_bluebubbles::native",
                                        "rust_lib_bluebubbles::native", "src/native.rs"), 29u32,
                                ::log::__private_api::Option::None);
                        }
                };
                handler.native_ready(state.get_ready().await, state.clone());
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("rpljslf dom"), lvl,
                                &("rust_lib_bluebubbles::native",
                                        "rust_lib_bluebubbles::native", "src/native.rs"), 31u32,
                                ::log::__private_api::Option::None);
                        }
                };
            });
    }
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_fn_func_init_native(dir:
            <String as ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        handler:
            <Arc<dyn MsgReceiver> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        call_status: &mut ::uniffi::RustCallStatus)
        -> <() as ::uniffi::LowerReturn<crate::UniFfiTag>>::ReturnType {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("init_native"), lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 19u32,
                        ::log::__private_api::Option::None);
                }
        };
        let uniffi_lift_args =
            move ||
                Ok((match <String as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(dir) {
                            Ok(v) => v,
                            Err(e) => return Err(("dir", e)),
                        },
                        match <Arc<dyn MsgReceiver> as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(handler) {
                            Ok(v) => v,
                            Err(e) => return Err(("handler", e)),
                        }));
        ::uniffi::rust_call(call_status,
            ||
                {
                    <() as
                            ::uniffi::LowerReturn<crate::UniFfiTag>>::lower_return(match uniffi_lift_args()
                            {
                            Ok(uniffi_args) => {
                                let uniffi_result =
                                    init_native(uniffi_args.0, uniffi_args.1);
                                uniffi_result
                            }
                            Err((arg_name, anyhow_error)) => {
                                <() as
                                        ::uniffi::LowerReturn<crate::UniFfiTag>>::handle_failed_lift(arg_name,
                                    anyhow_error)
                            }
                        })
                })
    }
    const UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_FUNC_INIT_NATIVE:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::FUNC).concat_str("rust_lib_bluebubbles").concat_str("init_native").concat_bool(false).concat_value(2u8).concat_str("dir").concat(<String
                                        as
                                        ::uniffi::Lift<crate::UniFfiTag>>::TYPE_ID_META).concat_bool(false).concat_str("handler").concat(<Arc<dyn MsgReceiver>
                            as
                            ::uniffi::Lift<crate::UniFfiTag>>::TYPE_ID_META).concat_bool(false).concat(<()
                    as
                    ::uniffi::LowerReturn<crate::UniFfiTag>>::TYPE_ID_META).concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static UNIFFI_META_RUST_LIB_BLUEBUBBLES_FUNC_INIT_NATIVE:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_FUNC_INIT_NATIVE.size] =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_FUNC_INIT_NATIVE.into_array();
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_checksum_func_init_native()
        -> u16 {
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_FUNC_INIT_NATIVE.checksum()
    }
    impl NativePushState {
        pub fn start_loop(self: Arc<NativePushState>,
            handler: Arc<dyn MsgReceiver>) {
            runtime().spawn(async move
                    {
                    loop {
                        match recv_wait(&self.state).await {
                            PollResult::Cont(Some(msg)) => {
                                let result = Box::into_raw(Box::new(msg)) as u64;
                                {
                                    let lvl = ::log::Level::Info;
                                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                lvl <= ::log::max_level() {
                                            ::log::__private_api::log(format_args!("emitting pointer {0}",
                                                    result), lvl,
                                                &("rust_lib_bluebubbles::native",
                                                        "rust_lib_bluebubbles::native", "src/native.rs"), 44u32,
                                                ::log::__private_api::Option::None);
                                        }
                                };
                                handler.receieved_msg(result);
                            }
                            PollResult::Cont(None) => continue,
                            PollResult::Stop => break,
                        }
                    }
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL &&
                                    lvl <= ::log::max_level() {
                                ::log::__private_api::log(format_args!("finishing loop"),
                                    lvl,
                                    &("rust_lib_bluebubbles::native",
                                            "rust_lib_bluebubbles::native", "src/native.rs"), 51u32,
                                    ::log::__private_api::Option::None);
                            }
                    };
                });
        }
        pub fn get_state(self: Arc<NativePushState>) -> u64 {
            let arc_val = Arc::into_raw(self.state.clone()) as u64;
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level()
                        {
                        ::log::__private_api::log(format_args!("emitting state {0}",
                                arc_val), lvl,
                            &("rust_lib_bluebubbles::native",
                                    "rust_lib_bluebubbles::native", "src/native.rs"), 57u32,
                            ::log::__private_api::Option::None);
                    }
            };
            arc_val
        }
        async fn get_ready(&self) -> bool {
            match get_phase(&self.state).await {
                RegistrationPhase::Registered => true,
                _ => false,
            }
        }
    }
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_fn_method_nativepushstate_start_loop(uniffi_self_lowered:
            <::std::sync::Arc<NativePushState> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        handler:
            <Arc<dyn MsgReceiver> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        call_status: &mut ::uniffi::RustCallStatus)
        -> <() as ::uniffi::LowerReturn<crate::UniFfiTag>>::ReturnType {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("start_loop"), lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 35u32,
                        ::log::__private_api::Option::None);
                }
        };
        let uniffi_lift_args =
            move ||
                Ok((match <::std::sync::Arc<NativePushState> as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(uniffi_self_lowered)
                            {
                            Ok(v) => v,
                            Err(e) => return Err(("self", e)),
                        },
                        match <Arc<dyn MsgReceiver> as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(handler) {
                            Ok(v) => v,
                            Err(e) => return Err(("handler", e)),
                        }));
        ::uniffi::rust_call(call_status,
            ||
                {
                    <() as
                            ::uniffi::LowerReturn<crate::UniFfiTag>>::lower_return(match uniffi_lift_args()
                            {
                            Ok(uniffi_args) => {
                                let uniffi_result = uniffi_args.0.start_loop(uniffi_args.1);
                                uniffi_result
                            }
                            Err((arg_name, anyhow_error)) => {
                                <() as
                                        ::uniffi::LowerReturn<crate::UniFfiTag>>::handle_failed_lift(arg_name,
                                    anyhow_error)
                            }
                        })
                })
    }
    const
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_START_LOOP:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::METHOD).concat_str("rust_lib_bluebubbles").concat_str("NativePushState").concat_str("start_loop").concat_bool(false).concat_value(1u8).concat_str("handler").concat(<Arc<dyn MsgReceiver>
                            as
                            ::uniffi::Lift<crate::UniFfiTag>>::TYPE_ID_META).concat_bool(false).concat(<()
                    as
                    ::uniffi::LowerReturn<crate::UniFfiTag>>::TYPE_ID_META).concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static
        UNIFFI_META_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_START_LOOP:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_START_LOOP.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_START_LOOP.into_array();
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_checksum_method_nativepushstate_start_loop()
        -> u16 {
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_START_LOOP.checksum()
    }
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_fn_method_nativepushstate_get_state(uniffi_self_lowered:
            <::std::sync::Arc<NativePushState> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType,
        call_status: &mut ::uniffi::RustCallStatus)
        -> <u64 as ::uniffi::LowerReturn<crate::UniFfiTag>>::ReturnType {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("get_state"), lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 35u32,
                        ::log::__private_api::Option::None);
                }
        };
        let uniffi_lift_args =
            move ||
                Ok((match <::std::sync::Arc<NativePushState> as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(uniffi_self_lowered)
                            {
                            Ok(v) => v,
                            Err(e) => return Err(("self", e)),
                        },));
        ::uniffi::rust_call(call_status,
            ||
                {
                    <u64 as
                            ::uniffi::LowerReturn<crate::UniFfiTag>>::lower_return(match uniffi_lift_args()
                            {
                            Ok(uniffi_args) => {
                                let uniffi_result = uniffi_args.0.get_state();
                                uniffi_result
                            }
                            Err((arg_name, anyhow_error)) => {
                                <u64 as
                                        ::uniffi::LowerReturn<crate::UniFfiTag>>::handle_failed_lift(arg_name,
                                    anyhow_error)
                            }
                        })
                })
    }
    const
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_STATE:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::METHOD).concat_str("rust_lib_bluebubbles").concat_str("NativePushState").concat_str("get_state").concat_bool(false).concat_value(0u8).concat(<u64
                    as
                    ::uniffi::LowerReturn<crate::UniFfiTag>>::TYPE_ID_META).concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static
        UNIFFI_META_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_STATE:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_STATE.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_STATE.into_array();
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_checksum_method_nativepushstate_get_state()
        -> u16 {
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_STATE.checksum()
    }
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_fn_method_nativepushstate_get_ready(uniffi_self_lowered:
            <::std::sync::Arc<NativePushState> as
            ::uniffi::Lift<crate::UniFfiTag>>::FfiType) -> ::uniffi::Handle {
        {
            let lvl = ::log::Level::Debug;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(format_args!("get_ready"), lvl,
                        &("rust_lib_bluebubbles::native",
                                "rust_lib_bluebubbles::native", "src/native.rs"), 35u32,
                        ::log::__private_api::Option::None);
                }
        };
        let uniffi_lift_args =
            move ||
                Ok((match <::std::sync::Arc<NativePushState> as
                                    ::uniffi::Lift<crate::UniFfiTag>>::try_lift(uniffi_self_lowered)
                            {
                            Ok(v) => v,
                            Err(e) => return Err(("self", e)),
                        },));
        match uniffi_lift_args() {
            Ok(uniffi_args) => {
                ::uniffi::rust_future_new::<_, bool,
                        _>(async move
                        {
                        let uniffi_result = uniffi_args.0.get_ready().await;
                        uniffi_result
                    }, crate::UniFfiTag)
            }
            Err((arg_name, anyhow_error)) => {
                ::uniffi::rust_future_new::<_, bool,
                        _>(async move
                        {
                        <bool as
                                ::uniffi::LowerReturn<crate::UniFfiTag>>::handle_failed_lift(arg_name,
                            anyhow_error)
                    }, crate::UniFfiTag)
            }
        }
    }
    const
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_READY:
        ::uniffi::MetadataBuffer =
        ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::METHOD).concat_str("rust_lib_bluebubbles").concat_str("NativePushState").concat_str("get_ready").concat_bool(true).concat_value(0u8).concat(<bool
                    as
                    ::uniffi::LowerReturn<crate::UniFfiTag>>::TYPE_ID_META).concat_long_str("");
    #[no_mangle]
    #[doc(hidden)]
    pub static
        UNIFFI_META_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_READY:
        [u8; UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_READY.size]
        =
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_READY.into_array();
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn uniffi_rust_lib_bluebubbles_checksum_method_nativepushstate_get_ready()
        -> u16 {
        UNIFFI_META_CONST_RUST_LIB_BLUEBUBBLES_METHOD_NATIVEPUSHSTATE_GET_READY.checksum()
    }
}
pub mod api {
    pub mod api {
        use std::{
            borrow::{Borrow, BorrowMut},
            future::Future, io::{Cursor, Write},
            path::PathBuf, str::FromStr, sync::{Arc, OnceLock},
            time::Duration,
        };
        use anyhow::anyhow;
        use flutter_rust_bridge::{frb, IntoDart, JoinHandle};
        use icloud_auth::{LoginState, AnisetteConfiguration, AppleAccount};
        pub use icloud_auth::{VerifyBody, TrustedPhoneNumber};
        pub use plist::Value;
        use prost::Message;
        pub use rustpush::{
            APNSState, APNSConnection, IDSAppleUser, PushError, IDSUser,
            IMClient, IMessage, ConversationData, register,
        };
        use serde::{Serialize, Deserialize};
        use tokio::{
            runtime::Runtime, select,
            sync::{
                oneshot::{self, Sender},
                Mutex, RwLock,
            },
        };
        use rustpush::{
            init_logger, Attachment, BalloonBody, MMCSFile, MessagePart,
            MessageParts, OSConfig, RegisterState,
        };
        pub use rustpush::{MacOSConfig, HardwareConfig};
        use uniffi::{
            deps::log::{info, error},
            HandleAlloc,
        };
        use std::io::Seek;
        use async_recursion::async_recursion;
        use crate::{frb_generated::StreamSink, runtime};
        use flutter_rust_bridge::for_generated::{
            SimpleHandler, SimpleExecutor, NoOpErrorListener,
            SimpleThreadPool, BaseAsyncRuntime, lazy_static,
        };
        pub type MyHandler =
            SimpleHandler<SimpleExecutor<NoOpErrorListener, SimpleThreadPool,
            MyAsyncRuntime>, NoOpErrorListener>;
        pub struct MyAsyncRuntime;
        #[automatically_derived]
        impl ::core::fmt::Debug for MyAsyncRuntime {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "MyAsyncRuntime")
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for MyAsyncRuntime {
            #[inline]
            fn default() -> MyAsyncRuntime { MyAsyncRuntime {} }
        }
        impl BaseAsyncRuntime for MyAsyncRuntime {
            fn spawn<F>(&self, future: F) -> JoinHandle<F::Output> where
                F: Future + Send + 'static, F::Output: Send + 'static {
                runtime().spawn(future)
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        pub struct FLUTTER_RUST_BRIDGE_HANDLER {
            __private_field: (),
        }
        #[doc(hidden)]
        pub static FLUTTER_RUST_BRIDGE_HANDLER: FLUTTER_RUST_BRIDGE_HANDLER =
            FLUTTER_RUST_BRIDGE_HANDLER { __private_field: () };
        impl ::lazy_static::__Deref for FLUTTER_RUST_BRIDGE_HANDLER {
            type Target = MyHandler;
            fn deref(&self) -> &MyHandler {
                #[inline(always)]
                fn __static_ref_initialize() -> MyHandler {
                    {
                        MyHandler::new(SimpleExecutor::new(NoOpErrorListener,
                                Default::default(), Default::default()), NoOpErrorListener)
                    }
                }
                #[inline(always)]
                fn __stability() -> &'static MyHandler {
                    static LAZY: ::lazy_static::lazy::Lazy<MyHandler> =
                        ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for FLUTTER_RUST_BRIDGE_HANDLER {
            fn initialize(lazy: &Self) { let _ = &**lazy; }
        }
        struct SavedState {
            push: APNSState,
            users: Vec<IDSUser>,
            os_config: MacOSConfig,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SavedState {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "SavedState", false as usize + 1 + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "push", &self.push)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "users", &self.users)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "os_config", &self.os_config)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SavedState {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, __field2, __ignore, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "push" => _serde::__private::Ok(__Field::__field0),
                                    "users" => _serde::__private::Ok(__Field::__field1),
                                    "os_config" => _serde::__private::Ok(__Field::__field2),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"push" => _serde::__private::Ok(__Field::__field0),
                                    b"users" => _serde::__private::Ok(__Field::__field1),
                                    b"os_config" => _serde::__private::Ok(__Field::__field2),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SavedState>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SavedState;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct SavedState")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<APNSState>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct SavedState with 3 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<Vec<IDSUser>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct SavedState with 3 elements")),
                                    };
                                let __field2 =
                                    match _serde::de::SeqAccess::next_element::<MacOSConfig>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(2usize,
                                                        &"struct SavedState with 3 elements")),
                                    };
                                _serde::__private::Ok(SavedState {
                                        push: __field0,
                                        users: __field1,
                                        os_config: __field2,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<APNSState> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<IDSUser>> =
                                    _serde::__private::None;
                                let mut __field2: _serde::__private::Option<MacOSConfig> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("push"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<APNSState>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("users"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<IDSUser>>(&mut __map)?);
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("os_config"));
                                                }
                                            __field2 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<MacOSConfig>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("push")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("users")?,
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("os_config")?,
                                    };
                                _serde::__private::Ok(SavedState {
                                        push: __field0,
                                        users: __field1,
                                        os_config: __field2,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] =
                            &["push", "users", "os_config"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "SavedState", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SavedState>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[automatically_derived]
        impl ::core::clone::Clone for SavedState {
            #[inline]
            fn clone(&self) -> SavedState {
                SavedState {
                    push: ::core::clone::Clone::clone(&self.push),
                    users: ::core::clone::Clone::clone(&self.users),
                    os_config: ::core::clone::Clone::clone(&self.os_config),
                }
            }
        }
        pub enum RegistrationPhase {
            WantsOSConfig,
            WantsUserPass,
            WantsRegister,
            Registered,
        }
        pub struct InnerPushState {
            pub conn: Option<Arc<APNSConnection>>,
            pub users: Vec<IDSUser>,
            pub client: Option<IMClient>,
            pub conf_dir: PathBuf,
            pub os_config: Option<Arc<MacOSConfig>>,
            pub account: Option<AppleAccount>,
            pub cancel_poll: Mutex<Option<Sender<()>>>,
        }
        pub struct PushState(pub RwLock<InnerPushState>);
        pub async fn new_push_state(dir: String)
            -> anyhow::Result<Arc<PushState>> {

            #[cfg(not(target_os = "android"))]
            init_logger();
            let state =
                PushState(RwLock::new(InnerPushState {
                            conn: None,
                            users: ::alloc::vec::Vec::new(),
                            client: None,
                            conf_dir: PathBuf::from_str(&dir).unwrap(),
                            os_config: None,
                            account: None,
                            cancel_poll: Mutex::new(None),
                        }));
            if PathBuf::from_str(&dir).unwrap().join("config.plist").exists()
                    {
                    restore(&state).await?;
                }
            Ok(Arc::new(state))
        }
        pub fn service_from_ptr(ptr: String) -> Arc<PushState> {
            let pointer: u64 = ptr.parse().unwrap();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level()
                        {
                        ::log::__private_api::log(format_args!("using state {0}",
                                pointer), lvl,
                            &("rust_lib_bluebubbles::api::api",
                                    "rust_lib_bluebubbles::api::api", "src/api/api.rs"), 96u32,
                            ::log::__private_api::Option::None);
                    }
            };
            let service =
                unsafe { Arc::from_raw(pointer as *const PushState) };
            service
        }
        fn plist_to_buf<T: serde::Serialize>(value: &T)
            -> Result<Vec<u8>, plist::Error> {
            let mut buf: Vec<u8> = Vec::new();
            let writer = Cursor::new(&mut buf);
            plist::to_writer_xml(writer, &value)?;
            Ok(buf)
        }
        fn plist_to_string<T: serde::Serialize>(value: &T)
            -> Result<String, plist::Error> {
            plist_to_buf(value).map(|val| String::from_utf8(val).unwrap())
        }
        fn plist_to_bin<T: serde::Serialize>(value: &T)
            -> Result<Vec<u8>, plist::Error> {
            let mut buf: Vec<u8> = Vec::new();
            let writer = Cursor::new(&mut buf);
            plist::to_writer_binary(writer, &value)?;
            Ok(buf)
        }
        async fn restore(curr_state: &PushState) -> anyhow::Result<()> {
            if !match curr_state.get_phase().await {
                            RegistrationPhase::WantsOSConfig => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (restore)"));
                    }
                }
            let mut inner = curr_state.0.write().await;
            let conf_path = inner.conf_dir.join("config.plist");
            let mut state: SavedState = plist::from_file(&conf_path)?;
            let connection =
                setup_push_rec(&state.os_config, Some(&state.push)).await;
            inner.os_config = Some(Arc::new(state.os_config.clone()));
            inner.conn = Some(connection);
            {
                ::std::io::_print(format_args!("registration expires at {0}\n",
                        state.users[0].identity.as_ref().unwrap().get_exp().unwrap()));
            };
            inner.client =
                Some(IMClient::new(inner.conn.as_ref().unwrap().clone(),
                            state.users.clone(), inner.conf_dir.join("id_cache.plist"),
                            inner.os_config.clone().unwrap(),
                            Box::new(move |updated_keys|
                                    {
                                        { ::std::io::_print(format_args!("updated keys!!!\n")); };
                                        state.users = updated_keys;
                                        std::fs::write(&conf_path,
                                                plist_to_string(&state).unwrap()).unwrap();
                                    })).await);
            Ok(())
        }
        #[repr(C)]
        pub struct DartSupportAction {
            pub url: String,
            pub button: String,
        }
        #[repr(C)]
        pub struct DartSupportAlert {
            pub title: String,
            pub body: String,
            pub action: Option<DartSupportAction>,
        }
        pub async fn register_ids(state: &Arc<PushState>)
            -> anyhow::Result<Option<DartSupportAlert>> {
            if !match state.get_phase().await {
                            RegistrationPhase::WantsRegister => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (register_ids)"));
                    }
                }
            let mut inner = state.0.write().await;
            let conn_state = inner.conn.as_ref().unwrap().clone();
            let mut empty_users = ::alloc::vec::Vec::new();
            std::mem::swap(&mut empty_users, &mut inner.users);
            if let Err(err) =
                        register(inner.os_config.as_ref().unwrap().as_ref(),
                                &mut empty_users, &conn_state).await {
                    return if let PushError::CustomerMessage(support) = err {
                                Ok(Some(unsafe { std::mem::transmute(support) }))
                            } else {
                               Err(::anyhow::__private::must_use({
                                           use ::anyhow::__private::kind::*;
                                           let error =
                                               match err { error => (&error).anyhow_kind().new(error), };
                                           error
                                       }))
                           }
                }
            let conf_path = inner.conf_dir.join("config.plist");
            let conf_path_dup = conf_path.clone();
            let mut state =
                SavedState {
                    push: inner.conn.as_ref().unwrap().clone_state().await,
                    users: empty_users.clone(),
                    os_config: inner.os_config.as_ref().unwrap().as_ref().clone(),
                };
            std::fs::write(&conf_path_dup,
                    plist_to_string(&state).unwrap()).unwrap();
            inner.client =
                Some(IMClient::new(conn_state, empty_users,
                            inner.conf_dir.join("id_cache.plist"),
                            inner.os_config.clone().unwrap(),
                            Box::new(move |updated_keys|
                                    {
                                        state.users = updated_keys;
                                        std::fs::write(&conf_path,
                                                plist_to_string(&state).unwrap()).unwrap();
                                    })).await);
            Ok(None)
        }
        async fn setup_push(config: &dyn OSConfig, state: Option<&APNSState>)
            -> anyhow::Result<Arc<APNSConnection>> {
            let connection =
                Arc::new(APNSConnection::new(config, state.cloned()).await?);
            Ok(connection)
        }
        #[must_use]
        fn setup_push_rec<'life0, 'life1,
            'async_recursion>(config: &'life0 dyn OSConfig,
            state: Option<&'life1 APNSState>)
            ->
                ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                Arc<APNSConnection>> + 'async_recursion +
                ::core::marker::Send>> where 'life0: 'async_recursion,
            'life1: 'async_recursion {
            Box::pin(async move
                    {
                    let Ok(push) =
                        setup_push(config,
                                state).await else {
                            tokio::time::sleep(Duration::from_secs(30)).await;
                            return setup_push_rec(config, state).await;
                        };
                    push
                })
        }
        pub async fn configure_macos(state: &Arc<PushState>,
            config: &MacOSConfig) -> anyhow::Result<()> {
            let config = config.clone();
            let mut inner = state.0.write().await;
            let connection = setup_push_rec(&config, None).await;
            inner.os_config = Some(Arc::new(config));
            inner.conn = Some(connection);
            Ok(())
        }
        pub struct DartHwExtra {
            pub version: String,
            pub protocol_version: u32,
            pub device_id: String,
            pub icloud_ua: String,
            pub aoskit_version: String,
        }
        pub fn config_from_validation_data(data: Vec<u8>, extra: DartHwExtra)
            -> anyhow::Result<MacOSConfig> {
            let inner = HardwareConfig::from_validation_data(&data)?;
            Ok(MacOSConfig {
                    inner,
                    version: extra.version,
                    protocol_version: extra.protocol_version,
                    device_id: extra.device_id,
                    icloud_ua: extra.icloud_ua,
                    aoskit_version: extra.aoskit_version,
                })
        }
        pub struct DartDeviceInfo {
            pub name: String,
            pub serial: String,
            pub os_version: String,
            pub encoded_data: Vec<u8>,
        }
        pub async fn get_device_info_state(state: &Arc<PushState>)
            -> anyhow::Result<DartDeviceInfo> {
            let locked = state.0.read().await;
            get_device_info(locked.os_config.as_ref().unwrap())
        }
        pub fn get_device_info(config: &MacOSConfig)
            -> anyhow::Result<DartDeviceInfo> {
            let copied = config.clone();
            Ok(DartDeviceInfo {
                    name: config.inner.product_name.clone(),
                    serial: config.inner.platform_serial_number.clone(),
                    os_version: config.version.clone(),
                    encoded_data: crate::bbhwinfo::HwInfo {
                            inner: Some(crate::bbhwinfo::hw_info::InnerHwInfo {
                                    product_name: copied.inner.product_name,
                                    io_mac_address: copied.inner.io_mac_address.to_vec(),
                                    platform_serial_number: copied.inner.platform_serial_number,
                                    platform_uuid: copied.inner.platform_uuid,
                                    root_disk_uuid: copied.inner.root_disk_uuid,
                                    board_id: copied.inner.board_id,
                                    os_build_num: copied.inner.os_build_num,
                                    platform_serial_number_enc: copied.inner.platform_serial_number_enc,
                                    platform_uuid_enc: copied.inner.platform_uuid_enc,
                                    root_disk_uuid_enc: copied.inner.root_disk_uuid_enc,
                                    rom: copied.inner.rom,
                                    rom_enc: copied.inner.rom_enc,
                                    mlb: copied.inner.mlb,
                                    mlb_enc: copied.inner.mlb_enc,
                                }),
                            version: copied.version,
                            protocol_version: copied.protocol_version as i32,
                            device_id: copied.device_id,
                            icloud_ua: copied.icloud_ua,
                            aoskit_version: copied.aoskit_version,
                        }.encode_to_vec(),
                })
        }
        pub fn config_from_encoded(encoded: Vec<u8>)
            -> anyhow::Result<MacOSConfig> {
            let copied =
                crate::bbhwinfo::HwInfo::decode(&mut Cursor::new(encoded))?;
            let inner = copied.inner.unwrap();
            Ok(MacOSConfig {
                    inner: HardwareConfig {
                        product_name: inner.product_name,
                        io_mac_address: inner.io_mac_address.try_into().unwrap(),
                        platform_serial_number: inner.platform_serial_number,
                        platform_uuid: inner.platform_uuid,
                        root_disk_uuid: inner.root_disk_uuid,
                        board_id: inner.board_id,
                        os_build_num: inner.os_build_num,
                        platform_serial_number_enc: inner.platform_serial_number_enc,
                        platform_uuid_enc: inner.platform_uuid_enc,
                        root_disk_uuid_enc: inner.root_disk_uuid_enc,
                        rom: inner.rom,
                        rom_enc: inner.rom_enc,
                        mlb: inner.mlb,
                        mlb_enc: inner.mlb_enc,
                    },
                    version: copied.version,
                    protocol_version: copied.protocol_version as u32,
                    device_id: copied.device_id,
                    icloud_ua: copied.icloud_ua,
                    aoskit_version: copied.aoskit_version,
                })
        }
        pub fn ptr_to_dart(ptr: String) -> DartIMessage {
            let pointer: u64 = ptr.parse().unwrap();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level()
                        {
                        ::log::__private_api::log(format_args!("using pointer {0}",
                                pointer), lvl,
                            &("rust_lib_bluebubbles::api::api",
                                    "rust_lib_bluebubbles::api::api", "src/api/api.rs"), 310u32,
                            ::log::__private_api::Option::None);
                    }
            };
            let recieved =
                unsafe { Box::from_raw(pointer as *mut DartIMessage) };
            *recieved
        }
        #[doc = r###"frb_marker: #[frb()]"###]
        #[repr(C)]
        pub struct DartBalloonBody {
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub bid: String,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub data: Vec<u8>,
        }
        #[doc = r###"frb_marker: #[frb()]"###]
        #[repr(C)]
        pub struct DartConversationData {
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub participants: Vec<String>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub cv_name: Option<String>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub sender_guid: Option<String>,
        }
        #[doc = r###"frb_marker: #[frb(non_opaque)]"###]
        #[repr(C)]
        pub enum DartLoginState {
            LoggedIn,
            NeedsDevice2FA,
            Needs2FAVerification,
            NeedsSMS2FA,
            NeedsSMS2FAVerification(VerifyBody),
            NeedsExtraStep(String),
            NeedsLogin,
        }
        #[repr(C)]
        pub struct DartMMCSFile {
            pub signature: Vec<u8>,
            pub object: String,
            pub url: String,
            pub key: Vec<u8>,
            pub size: usize,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DartMMCSFile {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "DartMMCSFile", false as usize + 1 + 1 + 1 + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "signature", &self.signature)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "object", &self.object)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "url", &self.url)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "key", &self.key)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "size", &self.size)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DartMMCSFile {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "signature" => _serde::__private::Ok(__Field::__field0),
                                    "object" => _serde::__private::Ok(__Field::__field1),
                                    "url" => _serde::__private::Ok(__Field::__field2),
                                    "key" => _serde::__private::Ok(__Field::__field3),
                                    "size" => _serde::__private::Ok(__Field::__field4),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"signature" => _serde::__private::Ok(__Field::__field0),
                                    b"object" => _serde::__private::Ok(__Field::__field1),
                                    b"url" => _serde::__private::Ok(__Field::__field2),
                                    b"key" => _serde::__private::Ok(__Field::__field3),
                                    b"size" => _serde::__private::Ok(__Field::__field4),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<DartMMCSFile>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DartMMCSFile;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct DartMMCSFile")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<Vec<u8>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct DartMMCSFile with 5 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct DartMMCSFile with 5 elements")),
                                    };
                                let __field2 =
                                    match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(2usize,
                                                        &"struct DartMMCSFile with 5 elements")),
                                    };
                                let __field3 =
                                    match _serde::de::SeqAccess::next_element::<Vec<u8>>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(3usize,
                                                        &"struct DartMMCSFile with 5 elements")),
                                    };
                                let __field4 =
                                    match _serde::de::SeqAccess::next_element::<usize>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(4usize,
                                                        &"struct DartMMCSFile with 5 elements")),
                                    };
                                _serde::__private::Ok(DartMMCSFile {
                                        signature: __field0,
                                        object: __field1,
                                        url: __field2,
                                        key: __field3,
                                        size: __field4,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0: _serde::__private::Option<Vec<u8>> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> =
                                    _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> =
                                    _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Vec<u8>> =
                                    _serde::__private::None;
                                let mut __field4: _serde::__private::Option<usize> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("signature"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("object"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("url"));
                                                }
                                            __field2 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("key"));
                                                }
                                            __field3 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?);
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("size"));
                                                }
                                            __field4 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<usize>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("signature")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("object")?,
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("url")?,
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("key")?,
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::__private::Some(__field4) => __field4,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("size")?,
                                    };
                                _serde::__private::Ok(DartMMCSFile {
                                        signature: __field0,
                                        object: __field1,
                                        url: __field2,
                                        key: __field3,
                                        size: __field4,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] =
                            &["signature", "object", "url", "key", "size"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "DartMMCSFile", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DartMMCSFile>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        impl DartMMCSFile {
            fn get_raw(&self) -> &MMCSFile {
                unsafe { std::mem::transmute(self) }
            }
        }
        impl From<MMCSFile> for DartMMCSFile {
            fn from(value: MMCSFile) -> Self {
                unsafe { std::mem::transmute(value) }
            }
        }
        #[repr(C)]
        pub enum DartAttachmentType { Inline(Vec<u8>), MMCS(DartMMCSFile), }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DartAttachmentType {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        match *self {
                            DartAttachmentType::Inline(ref __field0) =>
                                _serde::Serializer::serialize_newtype_variant(__serializer,
                                    "DartAttachmentType", 0u32, "Inline", __field0),
                            DartAttachmentType::MMCS(ref __field0) =>
                                _serde::Serializer::serialize_newtype_variant(__serializer,
                                    "DartAttachmentType", 1u32, "MMCS", __field0),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DartAttachmentType {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field { __field0, __field1, }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ =>
                                        _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "Inline" => _serde::__private::Ok(__Field::__field0),
                                    "MMCS" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"Inline" => _serde::__private::Ok(__Field::__field0),
                                    b"MMCS" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(_serde::de::Error::unknown_variant(__value,
                                                VARIANTS))
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<DartAttachmentType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DartAttachmentType;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "enum DartAttachmentType")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::EnumAccess<'de> {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) =>
                                        _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<Vec<u8>>(__variant),
                                            DartAttachmentType::Inline),
                                    (__Field::__field1, __variant) =>
                                        _serde::__private::Result::map(_serde::de::VariantAccess::newtype_variant::<DartMMCSFile>(__variant),
                                            DartAttachmentType::MMCS),
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] =
                            &["Inline", "MMCS"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                            "DartAttachmentType", VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DartAttachmentType>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        #[repr(C)]
        pub struct DartAttachment {
            pub a_type: DartAttachmentType,
            pub part_idx: u64,
            pub uti_type: String,
            pub mime: String,
            pub name: String,
            pub iris: bool,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DartAttachment {
                    fn serialize<__S>(&self, __serializer: __S)
                        -> _serde::__private::Result<__S::Ok, __S::Error> where
                        __S: _serde::Serializer {
                        let mut __serde_state =
                            _serde::Serializer::serialize_struct(__serializer,
                                    "DartAttachment", false as usize + 1 + 1 + 1 + 1 + 1 + 1)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "a_type", &self.a_type)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "part_idx", &self.part_idx)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "uti_type", &self.uti_type)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "mime", &self.mime)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "name", &self.name)?;
                        _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                "iris", &self.iris)?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                #[allow(unused_extern_crates, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DartAttachment {
                    fn deserialize<__D>(__deserializer: __D)
                        -> _serde::__private::Result<Self, __D::Error> where
                        __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    "a_type" => _serde::__private::Ok(__Field::__field0),
                                    "part_idx" => _serde::__private::Ok(__Field::__field1),
                                    "uti_type" => _serde::__private::Ok(__Field::__field2),
                                    "mime" => _serde::__private::Ok(__Field::__field3),
                                    "name" => _serde::__private::Ok(__Field::__field4),
                                    "iris" => _serde::__private::Ok(__Field::__field5),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                                -> _serde::__private::Result<Self::Value, __E> where
                                __E: _serde::de::Error {
                                match __value {
                                    b"a_type" => _serde::__private::Ok(__Field::__field0),
                                    b"part_idx" => _serde::__private::Ok(__Field::__field1),
                                    b"uti_type" => _serde::__private::Ok(__Field::__field2),
                                    b"mime" => _serde::__private::Ok(__Field::__field3),
                                    b"name" => _serde::__private::Ok(__Field::__field4),
                                    b"iris" => _serde::__private::Ok(__Field::__field5),
                                    _ => { _serde::__private::Ok(__Field::__ignore) }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                                -> _serde::__private::Result<Self, __D::Error> where
                                __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                    __FieldVisitor)
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<DartAttachment>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DartAttachment;
                            fn expecting(&self,
                                __formatter: &mut _serde::__private::Formatter)
                                -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(__formatter,
                                    "struct DartAttachment")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match _serde::de::SeqAccess::next_element::<DartAttachmentType>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                        &"struct DartAttachment with 6 elements")),
                                    };
                                let __field1 =
                                    match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                        &"struct DartAttachment with 6 elements")),
                                    };
                                let __field2 =
                                    match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(2usize,
                                                        &"struct DartAttachment with 6 elements")),
                                    };
                                let __field3 =
                                    match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(3usize,
                                                        &"struct DartAttachment with 6 elements")),
                                    };
                                let __field4 =
                                    match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(4usize,
                                                        &"struct DartAttachment with 6 elements")),
                                    };
                                let __field5 =
                                    match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)?
                                        {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None =>
                                            return _serde::__private::Err(_serde::de::Error::invalid_length(5usize,
                                                        &"struct DartAttachment with 6 elements")),
                                    };
                                _serde::__private::Ok(DartAttachment {
                                        a_type: __field0,
                                        part_idx: __field1,
                                        uti_type: __field2,
                                        mime: __field3,
                                        name: __field4,
                                        iris: __field5,
                                    })
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                                -> _serde::__private::Result<Self::Value, __A::Error> where
                                __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::__private::Option<DartAttachmentType> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<u64> =
                                    _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> =
                                    _serde::__private::None;
                                let mut __field3: _serde::__private::Option<String> =
                                    _serde::__private::None;
                                let mut __field4: _serde::__private::Option<String> =
                                    _serde::__private::None;
                                let mut __field5: _serde::__private::Option<bool> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                        _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("a_type"));
                                                }
                                            __field0 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<DartAttachmentType>(&mut __map)?);
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("part_idx"));
                                                }
                                            __field1 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<u64>(&mut __map)?);
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("uti_type"));
                                                }
                                            __field2 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("mime"));
                                                }
                                            __field3 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("name"));
                                                }
                                            __field4 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                    return _serde::__private::Err(<__A::Error as
                                                                    _serde::de::Error>::duplicate_field("iris"));
                                                }
                                            __field5 =
                                                _serde::__private::Some(_serde::de::MapAccess::next_value::<bool>(&mut __map)?);
                                        }
                                        _ => {
                                            let _ =
                                                _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("a_type")?,
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("part_idx")?,
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("uti_type")?,
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("mime")?,
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::__private::Some(__field4) => __field4,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("name")?,
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::__private::Some(__field5) => __field5,
                                        _serde::__private::None =>
                                            _serde::__private::de::missing_field("iris")?,
                                    };
                                _serde::__private::Ok(DartAttachment {
                                        a_type: __field0,
                                        part_idx: __field1,
                                        uti_type: __field2,
                                        mime: __field3,
                                        name: __field4,
                                        iris: __field5,
                                    })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] =
                            &["a_type", "part_idx", "uti_type", "mime", "name", "iris"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                            "DartAttachment", FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<DartAttachment>,
                                lifetime: _serde::__private::PhantomData,
                            })
                    }
                }
            };
        impl DartAttachment {
            pub fn save(&self) -> String { plist_to_string(self).unwrap() }
            pub fn restore(saved: String) -> DartAttachment {
                plist::from_reader_xml(Cursor::new(saved)).unwrap()
            }
            pub fn get_size(&self) -> usize { self.get_raw().get_size() }
            fn get_raw(&self) -> &Attachment {
                unsafe { std::mem::transmute(self) }
            }
        }
        impl From<Attachment> for DartAttachment {
            fn from(value: Attachment) -> Self {
                unsafe { std::mem::transmute(value) }
            }
        }
        #[repr(C)]
        pub enum DartMessagePart {
            Text(String),
            Attachment(DartAttachment),
            Mention(String, String),
        }
        #[repr(C)]
        pub enum DartPartExtension {
            Sticker {
                msg_width: f64,
                rotation: f64,
                sai: u64,
                scale: f64,
                update: Option<bool>,
                sli: u64,
                normalized_x: f64,
                normalized_y: f64,
                version: u64,
                hash: String,
                safi: u64,
                effect_type: i64,
                sticker_id: String,
            },
        }
        #[repr(C)]
        pub struct DartIndexedMessagePart {
            pub part: DartMessagePart,
            pub idx: Option<usize>,
            pub ext: Option<DartPartExtension>,
        }
        #[repr(C)]
        pub struct DartMessageParts(pub Vec<DartIndexedMessagePart>);
        impl DartMessageParts {
            fn get_raw(&self) -> &MessageParts {
                unsafe { std::mem::transmute(self) }
            }
            pub fn as_plain(&self) -> String { self.get_raw().raw_text() }
        }
        #[repr(C)]
        pub enum DartMessageType {
            IMessage,
            SMS {
                is_phone: bool,
                using_number: String,
                from_handle: Option<String>,
            },
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DartMessageType { }
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DartMessageType {
            #[inline]
            fn eq(&self, other: &DartMessageType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag =
                    ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag &&
                    match (self, other) {
                        (DartMessageType::SMS {
                            is_phone: __self_0,
                            using_number: __self_1,
                            from_handle: __self_2 }, DartMessageType::SMS {
                            is_phone: __arg1_0,
                            using_number: __arg1_1,
                            from_handle: __arg1_2 }) =>
                            *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1 &&
                                *__self_2 == *__arg1_2,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DartMessageType {
            #[inline]
            fn clone(&self) -> DartMessageType {
                match self {
                    DartMessageType::IMessage => DartMessageType::IMessage,
                    DartMessageType::SMS {
                        is_phone: __self_0,
                        using_number: __self_1,
                        from_handle: __self_2 } =>
                        DartMessageType::SMS {
                            is_phone: ::core::clone::Clone::clone(__self_0),
                            using_number: ::core::clone::Clone::clone(__self_1),
                            from_handle: ::core::clone::Clone::clone(__self_2),
                        },
                }
            }
        }
        #[doc = r###"frb_marker: #[frb()]"###]
        #[repr(C)]
        pub struct DartNormalMessage {
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub parts: DartMessageParts,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub body: Option<DartBalloonBody>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub effect: Option<String>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub reply_guid: Option<String>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub reply_part: Option<String>,
            pub service: DartMessageType,
        }
        #[repr(C)]
        pub struct DartRenameMessage {
            pub new_name: String,
        }
        #[repr(C)]
        pub struct DartChangeParticipantMessage {
            pub new_participants: Vec<String>,
            pub group_version: u64,
        }
        #[repr(C)]
        pub enum DartReaction {
            Heart,
            Like,
            Dislike,
            Laugh,
            Emphsize,
            Question,
        }
        #[doc = r###"frb_marker: #[frb(non_opaque)]"###]
        #[repr(C)]
        pub enum DartReactMessageType {
            React {
                reaction: DartReaction,
                enable: bool,
            },
            Extension {
                spec: Value,
                body: DartMessageParts,
            },
        }
        #[repr(C)]
        pub struct DartReactMessage {
            pub to_uuid: String,
            pub to_part: u64,
            pub reaction: DartReactMessageType,
            pub to_text: String,
        }
        #[repr(C)]
        pub struct DartUnsendMessage {
            pub tuuid: String,
            pub edit_part: u64,
        }
        #[repr(C)]
        pub struct DartEditMessage {
            pub tuuid: String,
            pub edit_part: u64,
            pub new_parts: DartMessageParts,
        }
        #[repr(C)]
        pub struct DartIconChangeMessage {
            pub file: Option<DartMMCSFile>,
            pub group_version: u64,
        }
        #[repr(C)]
        pub struct DartUpdateExtensionMessage {
            pub for_uuid: String,
            pub ext: DartPartExtension,
        }
        #[repr(C)]
        pub enum DartMessage {
            Message(DartNormalMessage),
            RenameMessage(DartRenameMessage),
            ChangeParticipants(DartChangeParticipantMessage),
            React(DartReactMessage),
            Delivered,
            Read,
            Typing,
            Unsend(DartUnsendMessage),
            Edit(DartEditMessage),
            IconChange(DartIconChangeMessage),
            StopTyping,
            EnableSmsActivation(bool),
            MessageReadOnDevice,
            SmsConfirmSent(bool),
            MarkUnread,
            PeerCacheInvalidate,
            UpdateExtension(DartUpdateExtensionMessage),
        }
        #[repr(C)]
        pub enum DartMessageTarget { Token(Vec<u8>), Uuid(String), }
        #[doc = r###"frb_marker: #[frb()]"###]
        #[repr(C)]
        pub struct DartIMessage {
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub id: String,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub sender: Option<String>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub after_guid: Option<String>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub conversation: Option<DartConversationData>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub message: DartMessage,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub sent_timestamp: u64,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub target: Option<Vec<DartMessageTarget>>,
            #[doc = r###"frb_marker: #[frb(non_final)]"###]
            pub send_delivered: bool,
        }
        impl Into<rustpush::Message> for DartMessage {
            fn into(self) -> rustpush::Message {
                unsafe { std::mem::transmute(self) }
            }
        }
        impl Into<ConversationData> for DartConversationData {
            fn into(self) -> ConversationData {
                unsafe { std::mem::transmute(self) }
            }
        }
        impl From<IMessage> for DartIMessage {
            fn from(value: IMessage) -> Self {
                unsafe { std::mem::transmute(value) }
            }
        }
        impl DartIMessage {
            fn to_imsg(self) -> IMessage {
                unsafe { std::mem::transmute(self) }
            }
        }
        pub enum PollResult { Stop, Cont(Option<DartIMessage>), }
        pub async fn recv_wait(state: &Arc<PushState>) -> PollResult {
            if !match state.get_phase().await {
                            RegistrationPhase::Registered => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (recv_wait)"));
                    }
                }
            let (send, recv) = oneshot::channel();
            let recv_path = state.0.read().await;
            *recv_path.cancel_poll.lock().await = Some(send);
            {
                #[doc(hidden)]
                mod __tokio_select_util {
                    pub(super) enum Out<_0, _1> { _0(_0), _1(_1), Disabled, }
                    pub(super) type Mask = u8;
                }
                use ::tokio::macros::support::Future;
                use ::tokio::macros::support::Pin;
                use ::tokio::macros::support::Poll::{Ready, Pending};
                const BRANCHES: u32 = 2;
                let mut disabled: __tokio_select_util::Mask =
                    Default::default();
                if !true {
                        let mask: __tokio_select_util::Mask = 1 << 0;
                        disabled |= mask;
                    }
                if !true {
                        let mask: __tokio_select_util::Mask = 1 << 1;
                        disabled |= mask;
                    }
                let mut output =
                    {
                        let mut futures =
                            (recv_path.client.as_ref().expect("no client??/").recieve_wait(),
                                recv);
                        let mut futures = &mut futures;
                        ::tokio::macros::support::poll_fn(|cx|
                                    {
                                        let mut is_pending = false;
                                        let start =
                                            { ::tokio::macros::support::thread_rng_n(BRANCHES) };
                                        for i in 0..BRANCHES {
                                            let branch;

                                            #[allow(clippy :: modulo_one)]
                                            { branch = (start + i) % BRANCHES; }
                                            match branch
                                                {
                                                    #[allow(unreachable_code)]
                                                    0 => {
                                                    let mask = 1 << branch;
                                                    if disabled & mask == mask { continue; }
                                                    let (fut, ..) = &mut *futures;
                                                    let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                    let out =
                                                        match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => { is_pending = true; continue; }
                                                        };
                                                    disabled |= mask;

                                                    #[allow(unused_variables)]
                                                    #[allow(unused_mut)]
                                                    match &out { msg => {} _ => continue, }
                                                    return Ready(__tokio_select_util::Out::_0(out));
                                                }
                                                    #[allow(unreachable_code)]
                                                    1 => {
                                                    let mask = 1 << branch;
                                                    if disabled & mask == mask { continue; }
                                                    let (_, fut, ..) = &mut *futures;
                                                    let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                    let out =
                                                        match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => { is_pending = true; continue; }
                                                        };
                                                    disabled |= mask;

                                                    #[allow(unused_variables)]
                                                    #[allow(unused_mut)]
                                                    match &out { _cancel => {} _ => continue, }
                                                    return Ready(__tokio_select_util::Out::_1(out));
                                                }
                                                _ => {
                                                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                                            format_args!("reaching this means there probably is an off by one bug")));
                                                }
                                            }
                                        }
                                        if is_pending {
                                                Pending
                                            } else { Ready(__tokio_select_util::Out::Disabled) }
                                    }).await
                    };
                match output {
                    __tokio_select_util::Out::_0(msg) => {
                        *recv_path.cancel_poll.lock().await = None;
                        let msg =
                            match msg {
                                Ok(msg) => msg,
                                Err(err) => {
                                    {
                                        let lvl = ::log::Level::Error;
                                        if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                    lvl <= ::log::max_level() {
                                                ::log::__private_api::log(format_args!("{0}", err), lvl,
                                                    &("rust_lib_bluebubbles::api::api",
                                                            "rust_lib_bluebubbles::api::api", "src/api/api.rs"), 647u32,
                                                    ::log::__private_api::Option::None);
                                            }
                                    };
                                    return PollResult::Cont(None);
                                }
                            };
                        PollResult::Cont(unsafe { std::mem::transmute(msg) })
                    }
                    __tokio_select_util::Out::_1(_cancel) => {
                        PollResult::Stop
                    }
                    __tokio_select_util::Out::Disabled => {
                        ::core::panicking::panic_fmt(format_args!("all branches are disabled and there is no else branch"));
                    }
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("failed to match bind")));
                    }
                }
            }
        }
        pub async fn send(state: &Arc<PushState>, msg: DartIMessage)
            -> anyhow::Result<()> {
            if !match state.get_phase().await {
                            RegistrationPhase::Registered => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (send)"));
                    }
                }
            let mut msg = msg.to_imsg();
            { ::std::io::_print(format_args!("sending_1\n")); };
            let inner = state.0.read().await;
            { ::std::io::_print(format_args!("sending_2\n")); };
            inner.client.as_ref().unwrap().send(&mut msg).await?;
            { ::std::io::_print(format_args!("sending_3\n")); };
            Ok(())
        }
        pub async fn get_handles(state: &Arc<PushState>)
            -> anyhow::Result<Vec<String>> {
            if !match state.get_phase().await {
                            RegistrationPhase::Registered => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (send)"));
                    }
                }
            Ok(state.0.read().await.client.as_ref().unwrap().get_handles().await.to_vec())
        }
        pub async fn do_reregister(state: &Arc<PushState>)
            -> anyhow::Result<()> {
            if !match state.get_phase().await {
                            RegistrationPhase::Registered => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (send)"));
                    }
                }
            state.0.read().await.client.as_ref().unwrap().reregister().await?;
            Ok(())
        }
        pub async fn new_msg(state: &Arc<PushState>,
            conversation: DartConversationData, sender: String,
            message: DartMessage) -> DartIMessage {
            if !match state.get_phase().await {
                            RegistrationPhase::Registered => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (new_msg)"));
                    }
                }
            let read = state.0.read().await;
            let client = read.client.as_ref().unwrap();
            client.new_msg(conversation.into(), &sender,
                        message.into()).await.into()
        }
        pub async fn validate_targets(state: &Arc<PushState>,
            targets: Vec<String>, sender: String)
            -> anyhow::Result<Vec<String>> {
            if !match state.get_phase().await {
                            RegistrationPhase::Registered => true,
                            _ => false,
                        } {
                    {
                        ::core::panicking::panic_fmt(format_args!("Wrong phase! (validate_targets)"));
                    }
                }
            Ok(state.0.read().await.client.as_ref().unwrap().validate_targets(&targets,
                            &sender).await?)
        }
        pub async fn get_phase(state: &Arc<PushState>) -> RegistrationPhase {
            state.get_phase().await
        }
        pub struct TransferProgress {
            pub prog: usize,
            pub total: usize,
            pub attachment: Option<DartAttachment>,
        }
        pub async fn download_attachment(sink: StreamSink<TransferProgress>,
            state: &Arc<PushState>, attachment: DartAttachment, path: String)
            -> anyhow::Result<()> {
            let inner = state.0.read().await;
            {
                ::std::io::_print(format_args!("donwloading file {0}\n",
                        path));
            };
            let path = std::path::Path::new(&path);
            let prefix = path.parent().unwrap();
            std::fs::create_dir_all(prefix)?;
            let mut file = std::fs::File::create(path)?;
            attachment.get_raw().get_attachment(inner.conn.as_ref().unwrap(),
                        &mut file,
                        &mut (|prog, total|
                                {
                                    {
                                        ::std::io::_print(format_args!("donwloading file {0} of {1}\n",
                                                prog, total));
                                    };
                                    sink.add(TransferProgress {
                                                prog,
                                                total,
                                                attachment: None,
                                            }).unwrap();
                                })).await?;
            file.flush()?;
            Ok(())
        }
        pub async fn download_mmcs(sink: StreamSink<TransferProgress>,
            state: &Arc<PushState>, attachment: DartMMCSFile, path: String)
            -> anyhow::Result<()> {
            let inner = state.0.read().await;
            let path = std::path::Path::new(&path);
            let prefix = path.parent().unwrap();
            std::fs::create_dir_all(prefix)?;
            let mut file = std::fs::File::create(path)?;
            attachment.get_raw().get_attachment(inner.conn.as_ref().unwrap(),
                        &mut file,
                        &mut (|prog, total|
                                {
                                    sink.add(TransferProgress {
                                                prog,
                                                total,
                                                attachment: None,
                                            }).unwrap();
                                })).await?;
            file.flush()?;
            Ok(())
        }
        pub struct MMCSTransferProgress {
            pub prog: usize,
            pub total: usize,
            pub file: Option<DartMMCSFile>,
        }
        pub async fn upload_mmcs(sink: StreamSink<MMCSTransferProgress>,
            state: &Arc<PushState>, path: String) -> anyhow::Result<()> {
            let inner = state.0.read().await;
            let mut file = std::fs::File::open(path)?;
            let prepared = MMCSFile::prepare_put(&mut file).await?;
            file.rewind()?;
            let attachment =
                MMCSFile::new(inner.conn.as_ref().unwrap(), &prepared,
                            &mut file,
                            &mut (|prog, total|
                                    {
                                        sink.add(MMCSTransferProgress {
                                                    prog,
                                                    total,
                                                    file: None,
                                                }).unwrap();
                                    })).await?;
            sink.add(MMCSTransferProgress {
                        prog: 0,
                        total: 0,
                        file: Some(attachment.into()),
                    }).unwrap();
            Ok(())
        }
        pub async fn upload_attachment(sink: StreamSink<TransferProgress>,
            state: &Arc<PushState>, path: String, mime: String, uti: String,
            name: String) -> anyhow::Result<()> {
            let inner = state.0.read().await;
            let mut file = std::fs::File::open(path)?;
            let prepared = MMCSFile::prepare_put(&mut file).await?;
            file.rewind()?;
            let attachment =
                Attachment::new_mmcs(inner.conn.as_ref().unwrap(), &prepared,
                            &mut file, &mime, &uti, &name,
                            &mut (|prog, total|
                                    {
                                        sink.add(TransferProgress {
                                                    prog,
                                                    total,
                                                    attachment: None,
                                                }).unwrap();
                                    })).await?;
            sink.add(TransferProgress {
                        prog: 0,
                        total: 0,
                        attachment: Some(attachment.into()),
                    }).unwrap();
            Ok(())
        }
        pub async fn try_auth(state: &Arc<PushState>, username: String,
            password: String) -> anyhow::Result<DartLoginState> {
            let connection =
                state.0.read().await.conn.as_ref().unwrap().clone();
            let mut inner = state.0.write().await;
            let anisette_config =
                AnisetteConfiguration::new().set_configuration_path(inner.conf_dir.join("anisette_test"));
            let mut apple_account = AppleAccount::new(anisette_config).await?;
            let mut login_state =
                apple_account.login_email_pass(&username, &password).await?;
            if let Some(pet) = apple_account.get_pet() {
                    let identity =
                        IDSAppleUser::authenticate(&connection, username.trim(),
                                    &pet, inner.os_config.as_ref().unwrap().as_ref()).await?;
                    inner.users.push(identity);
                    {
                        ::std::io::_print(format_args!("confirmed login {0:?}\n",
                                login_state));
                    };
                    if match login_state {
                                LoginState::NeedsExtraStep(_) => true,
                                _ => false,
                            } {
                            login_state = LoginState::LoggedIn;
                        }
                }
            inner.account = Some(apple_account);
            Ok(unsafe { std::mem::transmute(login_state) })
        }
        pub async fn send_2fa_to_devices(state: &Arc<PushState>)
            -> anyhow::Result<DartLoginState> {
            let inner = state.0.read().await;
            let account = inner.account.as_ref().unwrap();
            Ok(unsafe {
                    std::mem::transmute(account.send_2fa_to_devices().await?)
                })
        }
        pub async fn verify_2fa(state: &Arc<PushState>, code: String)
            -> anyhow::Result<DartLoginState> {
            let inner = state.0.read().await;
            let account = inner.account.as_ref().unwrap();
            Ok(unsafe {
                    std::mem::transmute(account.verify_2fa(code).await?)
                })
        }
        #[repr(C)]
        pub struct DartTrustedPhoneNumber {
            pub number_with_dial_code: String,
            pub last_two_digits: String,
            pub push_mode: String,
            pub id: u32,
        }
        pub async fn get_2fa_sms_opts(state: &Arc<PushState>)
            ->
                anyhow::Result<(Vec<DartTrustedPhoneNumber>,
                Option<DartLoginState>)> {
            let inner = state.0.read().await;
            let account = inner.account.as_ref().unwrap();
            let extras = account.get_auth_extras().await?;
            Ok((extras.trusted_phone_numbers.into_iter().map(|i|
                                unsafe { std::mem::transmute(i) }).collect(),
                    extras.new_state.map(|i|
                            unsafe { std::mem::transmute(i) })))
        }
        pub async fn send_2fa_sms(state: &Arc<PushState>, phone_id: u32)
            -> anyhow::Result<DartLoginState> {
            let inner = state.0.read().await;
            let account = inner.account.as_ref().unwrap();
            Ok(unsafe {
                    std::mem::transmute(account.send_sms_2fa_to_devices(phone_id).await?)
                })
        }
        pub async fn verify_2fa_sms(state: &Arc<PushState>, body: &VerifyBody,
            code: String) -> anyhow::Result<DartLoginState> {
            let inner = state.0.read().await;
            let account = inner.account.as_ref().unwrap();
            Ok(unsafe {
                    std::mem::transmute(account.verify_sms_2fa(code,
                                    body.clone()).await?)
                })
        }
        pub async fn reset_state(state: &Arc<PushState>)
            -> anyhow::Result<()> {
            let inner = state.0.read().await;
            if let Some(cancel) = inner.cancel_poll.lock().await.take() {
                    cancel.send(()).unwrap();
                }
            drop(inner);
            let mut inner = state.0.write().await;
            let conn_state = inner.conn.as_ref().unwrap().clone();
            inner.client = None;
            let _ =
                register(inner.os_config.as_ref().unwrap().as_ref(), &mut [],
                        &conn_state).await;
            inner.conn = None;
            inner.os_config = None;
            inner.account = None;
            inner.users = ::alloc::vec::Vec::new();
            let _ = std::fs::remove_file(inner.conf_dir.join("config.plist"));
            let _ =
                std::fs::remove_file(inner.conf_dir.join("id_cache.plist"));
            Ok(())
        }
        pub async fn invalidate_id_cache(state: &Arc<PushState>)
            -> anyhow::Result<()> {
            let inner = state.0.read().await;
            inner.client.as_ref().unwrap().invalidate_id_cache().await;
            Ok(())
        }
        impl PushState {
            async fn get_phase(&self) -> RegistrationPhase {
                let inner = self.0.read().await;
                if inner.os_config.is_none() {
                        return RegistrationPhase::WantsOSConfig
                    }
                if inner.users.len() == 0 && inner.client.is_none() {
                        return RegistrationPhase::WantsUserPass
                    }
                if inner.client.is_none() {
                        return RegistrationPhase::WantsRegister
                    }
                RegistrationPhase::Registered
            }
        }
        pub async fn get_user_name(state: &Arc<PushState>)
            -> anyhow::Result<String> {
            let inner = state.0.read().await;
            let (first, last) = inner.account.as_ref().unwrap().get_name();
            Ok({
                    let res =
                        ::alloc::fmt::format(format_args!("{0} {1}", first, last));
                    res
                })
        }
        pub enum DartRegisterState {
            Registered,
            Registering,
            Failed {
                retry_wait: Option<u64>,
                error: String,
            },
        }
        pub async fn get_regstate(state: &Arc<PushState>)
            -> anyhow::Result<DartRegisterState> {
            let inner = state.0.read().await;
            let mutex_ref =
                inner.client.as_ref().unwrap().get_regstate().await;
            let regstate = mutex_ref.lock().await;
            Ok(match &*regstate {
                    RegisterState::Registering =>
                        DartRegisterState::Registering,
                    RegisterState::Registered => DartRegisterState::Registered,
                    RegisterState::Failed(failure) =>
                        DartRegisterState::Failed {
                            retry_wait: failure.retry_wait,
                            error: {
                                let res =
                                    ::alloc::fmt::format(format_args!("{0}", failure.error));
                                res
                            },
                        },
                })
        }
        pub async fn convert_token_to_uuid(state: &Arc<PushState>,
            handle: String, token: Vec<u8>) -> anyhow::Result<String> {
            let inner = state.0.read().await;
            let uuid =
                inner.client.as_ref().unwrap().token_to_uuid(&handle,
                            &token).await?;
            Ok(uuid)
        }
        #[repr(C)]
        pub struct DartPrivateDeviceInfo {
            pub uuid: Option<String>,
            pub device_name: Option<String>,
            pub token: Vec<u8>,
            pub is_hsa_trusted: bool,
            pub identites: Vec<String>,
            pub sub_services: Vec<String>,
        }
        pub async fn get_sms_targets(state: &Arc<PushState>, handle: String,
            refresh: bool) -> anyhow::Result<Vec<DartPrivateDeviceInfo>> {
            let inner = state.0.read().await;
            let targets =
                inner.client.as_ref().unwrap().get_sms_targets(&handle,
                            refresh).await?;
            Ok(unsafe { std::mem::transmute(targets) })
        }
    }
}
mod frb_generated {
    #![allow(non_camel_case_types, unused, non_snake_case,
    clippy::needless_return, clippy::redundant_closure_call,
    clippy::redundant_closure, clippy::useless_conversion, clippy::unit_arg,
    clippy::unused_unit, clippy::double_parens, clippy::let_and_return,
    clippy::too_many_arguments, clippy::match_single_binding)]
    use crate::api::api::*;
    use flutter_rust_bridge::{Handler, IntoIntoDart};
    use flutter_rust_bridge::for_generated::transform_result_dco;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, WriteBytesExt, ReadBytesExt,
    };
    #[doc(hidden)]
    pub(crate) struct FrbWrapper<T>(T);
    impl<T: Clone> Clone for FrbWrapper<T> {
        fn clone(&self) -> Self { FrbWrapper(self.0.clone()) }
    }
    impl<T: PartialEq> PartialEq for FrbWrapper<T> {
        fn eq(&self, other: &Self) -> bool { self.0.eq(&other.0) }
    }
    impl<T: Eq> Eq for FrbWrapper<T> {}
    impl<T: std::hash::Hash> std::hash::Hash for FrbWrapper<T> {
        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
            self.0.hash(state)
        }
    }
    impl<T> From<T> for FrbWrapper<T> {
        fn from(t: T) -> Self { FrbWrapper(t) }
    }
    use std::collections::HashMap;
    use std::marker::PhantomData;
    use std::sync::Arc;
    pub struct MoiArc<T: ?Sized + MoiArcValue> {
        object_id: Option<ObjectId>,
        value: Option<Arc<T>>,
        _phantom: PhantomData<T>,
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug + ?Sized + MoiArcValue> ::core::fmt::Debug for
        MoiArc<T> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(f, "MoiArc",
                "object_id", &self.object_id, "value", &self.value,
                "_phantom", &&self._phantom)
        }
    }
    impl<T: ?Sized + MoiArcValue> Drop for MoiArc<T> {
        fn drop(&mut self) {
            if let Some(object_id) = self.object_id {
                    Self::decrement_strong_count(object_id);
                }
        }
    }
    impl<T: ?Sized + MoiArcValue> AsRef<T> for MoiArc<T> {
        fn as_ref(&self) -> &T { self.value.as_ref().unwrap().as_ref() }
    }
    impl<T: ?Sized + MoiArcValue>
        ::flutter_rust_bridge::for_generated::BaseArc<T> for MoiArc<T> {
        fn new(value: T) -> Self where T: Sized {
            let mut pool = T::get_pool().write().unwrap();
            let object_id = pool.id_generator.next_id();
            let value = Arc::new(value);
            let old_value =
                pool.map.insert(object_id,
                    MoiArcPoolValue { ref_count: 1, value: value.clone() });
            if !old_value.is_none() {
                    ::core::panicking::panic("assertion failed: old_value.is_none()")
                };
            Self {
                object_id: Some(object_id),
                value: Some(value),
                _phantom: PhantomData,
            }
        }
        fn try_unwrap(mut self) -> Result<T, Self> where T: Sized {
            let pool = &mut T::get_pool().write().unwrap();
            if pool.map.get(&self.object_id.unwrap()).unwrap().ref_count == 1
                    {
                    Self::decrement_strong_count_raw(self.object_id.unwrap(),
                        pool);
                    self.object_id.take().unwrap();
                    Ok(Arc::into_inner(self.value.take().unwrap()).unwrap())
                } else { Err(self) }
        }
        fn into_inner(self) -> Option<T> where T: Sized {
            self.try_unwrap().ok()
        }
        fn into_raw(mut self) -> usize { self.object_id.take().unwrap() }
    }
    impl<T: ?Sized + MoiArcValue> Clone for MoiArc<T> {
        fn clone(&self) -> Self {
            Self::increment_strong_count(self.object_id.unwrap());
            Self {
                object_id: self.object_id,
                value: self.value.clone(),
                _phantom: PhantomData,
            }
        }
    }
    impl<T: ?Sized + MoiArcValue> MoiArc<T> {
        pub(crate) fn from_raw(raw: usize) -> Self where T: Sized {
            let map = &T::get_pool().read().unwrap().map;
            Self {
                object_id: Some(raw),
                value: Some(map.get(&raw).unwrap().value.clone()),
                _phantom: PhantomData,
            }
        }
        pub fn increment_strong_count(raw: usize) {
            let map = &mut T::get_pool().write().unwrap().map;
            map.get_mut(&raw).unwrap().ref_count += 1;
        }
        pub fn decrement_strong_count(raw: usize) {
            Self::decrement_strong_count_raw(raw,
                &mut T::get_pool().write().unwrap())
        }
        fn decrement_strong_count_raw(raw: usize,
            pool: &mut MoiArcPoolInner<T>) {
            let value = pool.map.get_mut(&raw).unwrap();
            value.ref_count -= 1;
            if value.ref_count == 0 { pool.map.remove(&raw).unwrap(); }
        }
    }
    pub trait MoiArcValue: 'static {
        fn get_pool()
        -> &'static MoiArcPool<Self>;
    }
    type ObjectId = usize;
    pub type MoiArcPool<T> = std::sync::RwLock<MoiArcPoolInner<T>>;
    pub struct MoiArcPoolInner<T: ?Sized> {
        map: HashMap<ObjectId, MoiArcPoolValue<T>>,
        id_generator: IdGenerator,
    }
    impl<T: ?Sized> Default for MoiArcPoolInner<T> {
        fn default() -> Self {
            Self { map: HashMap::new(), id_generator: Default::default() }
        }
    }
    struct IdGenerator {
        next_id: ObjectId,
    }
    impl Default for IdGenerator {
        fn default() -> Self { Self { next_id: Self::MIN_ID } }
    }
    impl IdGenerator {
        const MIN_ID: ObjectId = 1;
        const MAX_ID: ObjectId = 2147483600;
        fn next_id(&mut self) -> ObjectId {
            let ans = self.next_id;
            self.next_id =
                if self.next_id >= Self::MAX_ID {
                        Self::MIN_ID
                    } else { self.next_id + 1 };
            ans
        }
    }
    impl<T: ?Sized> MoiArcPoolInner<T> {}
    struct MoiArcPoolValue<T: ?Sized> {
        ref_count: i32,
        value: Arc<T>,
    }
    use ::flutter_rust_bridge::for_generated::decode_rust_opaque_nom;
    fn decode_rust_opaque_moi<T: MoiArcValue + Send + Sync>(ptr: usize)
        -> RustOpaqueMoi<T> {
        RustOpaqueMoi::from_arc(MoiArc::<T>::from_raw(ptr))
    }
    use ::flutter_rust_bridge::for_generated::StdArc;
    use ::flutter_rust_bridge::RustOpaqueNom;
    /// Please refer to `RustOpaque` for doc.
    pub type RustOpaqueMoi<T> =
        ::flutter_rust_bridge::for_generated::RustOpaqueBase<T, MoiArc<T>>;
    /// A wrapper to support [arbitrary Rust types](https://cjycode.com/flutter_rust_bridge/guides/types/arbitrary).
    pub type RustOpaque<T> = RustOpaqueMoi<T>;
    use ::flutter_rust_bridge::RustAutoOpaqueNom;
    /// Please refer to `RustAutoOpaque` for doc.
    pub type RustAutoOpaqueMoi<T> =
        ::flutter_rust_bridge::for_generated::RustAutoOpaqueBase<T,
        MoiArc<::flutter_rust_bridge::for_generated::RustAutoOpaqueInner<T>>>;
    /// Usually this is unneeded, and just write down arbitrary types.
    /// However, when you need arbitrary types at places that are not supported yet,
    /// use `RustOpaqueOpaque<YourArbitraryType>`.
    pub type RustAutoOpaque<T> = RustAutoOpaqueMoi<T>;
    pub trait CstDecode<T> {
        fn cst_decode(self)
        -> T;
    }
    impl<T, S> CstDecode<Option<T>> for *mut S where *mut S: CstDecode<T> {
        fn cst_decode(self) -> Option<T> {
            (!self.is_null()).then(|| self.cst_decode())
        }
    }
    pub trait SseDecode {
        fn sse_decode(deserializer:
            &mut ::flutter_rust_bridge::for_generated::SseDeserializer)
        -> Self;
        fn sse_decode_single(message:
                ::flutter_rust_bridge::for_generated::Dart2RustMessageSse)
            -> Self where Self: Sized {
            let mut deserializer =
                ::flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let ans = Self::sse_decode(&mut deserializer);
            deserializer.end();
            ans
        }
    }
    pub trait SseEncode {
        fn sse_encode(self,
        serializer: &mut ::flutter_rust_bridge::for_generated::SseSerializer);
    }
    fn transform_result_sse<T, E>(raw: Result<T, E>)
        ->
            Result<::flutter_rust_bridge::for_generated::Rust2DartMessageSse,
            ::flutter_rust_bridge::for_generated::Rust2DartMessageSse> where
        T: SseEncode, E: SseEncode {
        use ::flutter_rust_bridge::for_generated::{Rust2DartAction, SseCodec};
        match raw {
            Ok(raw) =>
                Ok(SseCodec::encode(Rust2DartAction::Success,
                        |serializer| { raw.sse_encode(serializer) })),
            Err(raw) =>
                Err(SseCodec::encode(Rust2DartAction::Error,
                        |serializer| { raw.sse_encode(serializer) })),
        }
    }
    pub struct StreamSink<T,
        Rust2DartCodec: ::flutter_rust_bridge::for_generated::BaseCodec =
        ::flutter_rust_bridge::for_generated::SseCodec> {
        base: ::flutter_rust_bridge::for_generated::StreamSinkBase<T,
        Rust2DartCodec>,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone, Rust2DartCodec: ::core::clone::Clone +
        ::flutter_rust_bridge::for_generated::BaseCodec> ::core::clone::Clone
        for StreamSink<T, Rust2DartCodec> {
        #[inline]
        fn clone(&self) -> StreamSink<T, Rust2DartCodec> {
            StreamSink { base: ::core::clone::Clone::clone(&self.base) }
        }
    }
    impl<T, Rust2DartCodec: ::flutter_rust_bridge::for_generated::BaseCodec>
        StreamSink<T, Rust2DartCodec> {
        pub fn deserialize(raw: String) -> Self {
            Self {
                base: ::flutter_rust_bridge::for_generated::StreamSinkBase::deserialize(raw),
            }
        }
    }
    impl<T> StreamSink<T, ::flutter_rust_bridge::for_generated::DcoCodec> {
        pub fn add<T2>(&self, value: T)
            -> Result<(), ::flutter_rust_bridge::Rust2DartSendError> where
            T: ::flutter_rust_bridge::IntoIntoDart<T2>,
            T2: ::flutter_rust_bridge::IntoDart {
            self.base.add(::flutter_rust_bridge::for_generated::DcoCodec::encode(::flutter_rust_bridge::for_generated::Rust2DartAction::Success,
                    value.into_into_dart()))
        }
    }
    impl<T> StreamSink<T, ::flutter_rust_bridge::for_generated::SseCodec>
        where T: SseEncode {
        pub fn add(&self, value: T)
            -> Result<(), ::flutter_rust_bridge::Rust2DartSendError> {
            self.base.add(::flutter_rust_bridge::for_generated::SseCodec::encode(::flutter_rust_bridge::for_generated::Rust2DartAction::Success,
                    |serializer| value.sse_encode(serializer)))
        }
    }
    impl<T, Rust2DartCodec: ::flutter_rust_bridge::for_generated::BaseCodec>
        ::flutter_rust_bridge::IntoIntoDart<StreamSink<T, Rust2DartCodec>> for
        StreamSink<T, Rust2DartCodec> {
        fn into_into_dart(self) -> StreamSink<T, Rust2DartCodec> {
            ::core::panicking::panic("internal error: entered unreachable code")
        }
    }
    impl<T, Rust2DartCodec: ::flutter_rust_bridge::for_generated::BaseCodec>
        ::flutter_rust_bridge::IntoDart for StreamSink<T, Rust2DartCodec> {
        fn into_dart(self) -> ::flutter_rust_bridge::for_generated::DartAbi {
            ::core::panicking::panic("internal error: entered unreachable code")
        }
    }
    pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str =
        "2.0.0-dev.33";
    pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 =
        -1867643805;
    pub use crate::api::api::FLUTTER_RUST_BRIDGE_HANDLER;
    fn wire_config_from_encoded_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "config_from_encoded",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_encoded = <Vec<u8>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            { crate::api::api::config_from_encoded(api_encoded) })())
                        }
                })
    }
    fn wire_config_from_validation_data_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "config_from_validation_data",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
                    let api_extra =
                        <crate::api::api::DartHwExtra>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                crate::api::api::config_from_validation_data(api_data,
                                                    api_extra)
                                            })())
                        }
                })
    }
    fn wire_configure_macos_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "configure_macos",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_config =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let mut api_config_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false),
                                                                            api_config.rust_auto_opaque_lock_order_info(1, false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            1 =>
                                                                api_config_decoded =
                                                                    Some(api_config.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    let api_config = api_config_decoded.unwrap();
                                                    crate::api::api::configure_macos(&api_state,
                                                            &api_config).await
                                                })().await)
                        }
                })
    }
    fn wire_convert_token_to_uuid_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "convert_token_to_uuid",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_handle = <String>::sse_decode(&mut deserializer);
                    let api_token = <Vec<u8>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::convert_token_to_uuid(&api_state,
                                                            api_handle, api_token).await
                                                })().await)
                        }
                })
    }
    fn wire_dart_attachment_get_size_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "dart_attachment_get_size",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_that =
                        <crate::api::api::DartAttachment>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                Result::<_,
                                                        ()>::Ok(crate::api::api::DartAttachment::get_size(&api_that))
                                            })())
                        }
                })
    }
    fn wire_dart_attachment_restore_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "dart_attachment_restore",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_saved = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                Result::<_,
                                                        ()>::Ok(crate::api::api::DartAttachment::restore(api_saved))
                                            })())
                        }
                })
    }
    fn wire_dart_attachment_save_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "dart_attachment_save",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_that =
                        <crate::api::api::DartAttachment>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                Result::<_,
                                                        ()>::Ok(crate::api::api::DartAttachment::save(&api_that))
                                            })())
                        }
                })
    }
    fn wire_dart_message_parts_as_plain_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "dart_message_parts_as_plain",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_that =
                        <crate::api::api::DartMessageParts>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                Result::<_,
                                                        ()>::Ok(crate::api::api::DartMessageParts::as_plain(&api_that))
                                            })())
                        }
                })
    }
    fn wire_do_reregister_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "do_reregister",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::do_reregister(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_download_attachment_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "download_attachment",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_sink =
                        <StreamSink<crate::api::api::TransferProgress,
                                flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_attachment =
                        <crate::api::api::DartAttachment>::sse_decode(&mut deserializer);
                    let api_path = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::download_attachment(api_sink, &api_state,
                                                            api_attachment, api_path).await
                                                })().await)
                        }
                })
    }
    fn wire_download_mmcs_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "download_mmcs",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_sink =
                        <StreamSink<crate::api::api::TransferProgress,
                                flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_attachment =
                        <crate::api::api::DartMMCSFile>::sse_decode(&mut deserializer);
                    let api_path = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::download_mmcs(api_sink, &api_state,
                                                            api_attachment, api_path).await
                                                })().await)
                        }
                })
    }
    fn wire_get_2fa_sms_opts_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_2fa_sms_opts",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::get_2fa_sms_opts(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_get_device_info_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_device_info",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_config =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                let mut api_config_decoded = None;
                                                let decode_indices_ =
                                                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_config.rust_auto_opaque_lock_order_info(0,
                                                                            false)])));
                                                for i in decode_indices_ {
                                                    match i {
                                                        0 =>
                                                            api_config_decoded =
                                                                Some(api_config.rust_auto_opaque_decode_sync_ref()),
                                                        _ =>
                                                            ::core::panicking::panic("internal error: entered unreachable code"),
                                                    }
                                                }
                                                let api_config = api_config_decoded.unwrap();
                                                crate::api::api::get_device_info(&api_config)
                                            })())
                        }
                })
    }
    fn wire_get_device_info_state_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_device_info_state",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::get_device_info_state(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_get_handles_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_handles",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::get_handles(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_get_phase_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_phase",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    Result::<_,
                                                            ()>::Ok(crate::api::api::get_phase(&api_state).await)
                                                })().await)
                        }
                })
    }
    fn wire_get_regstate_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_regstate",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::get_regstate(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_get_sms_targets_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_sms_targets",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_handle = <String>::sse_decode(&mut deserializer);
                    let api_refresh = <bool>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::get_sms_targets(&api_state, api_handle,
                                                            api_refresh).await
                                                })().await)
                        }
                })
    }
    fn wire_get_user_name_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "get_user_name",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::get_user_name(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_invalidate_id_cache_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "invalidate_id_cache",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::invalidate_id_cache(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_new_msg_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "new_msg",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_conversation =
                        <crate::api::api::DartConversationData>::sse_decode(&mut deserializer);
                    let api_sender = <String>::sse_decode(&mut deserializer);
                    let api_message =
                        <crate::api::api::DartMessage>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    Result::<_,
                                                            ()>::Ok(crate::api::api::new_msg(&api_state,
                                                                api_conversation, api_sender, api_message).await)
                                                })().await)
                        }
                })
    }
    fn wire_new_push_state_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "new_push_state",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_dir = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    { crate::api::api::new_push_state(api_dir).await })().await)
                        }
                })
    }
    fn wire_ptr_to_dart_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "ptr_to_dart",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_ptr = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                Result::<_, ()>::Ok(crate::api::api::ptr_to_dart(api_ptr))
                                            })())
                        }
                })
    }
    fn wire_recv_wait_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "recv_wait",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    Result::<_,
                                                            ()>::Ok(crate::api::api::recv_wait(&api_state).await)
                                                })().await)
                        }
                })
    }
    fn wire_register_ids_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "register_ids",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::register_ids(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_reset_state_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "reset_state",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::reset_state(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_send_impl(port_: flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "send",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_msg =
                        <crate::api::api::DartIMessage>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::send(&api_state, api_msg).await
                                                })().await)
                        }
                })
    }
    fn wire_send_2fa_sms_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "send_2fa_sms",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_phone_id = <u32>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::send_2fa_sms(&api_state,
                                                            api_phone_id).await
                                                })().await)
                        }
                })
    }
    fn wire_send_2fa_to_devices_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "send_2fa_to_devices",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::send_2fa_to_devices(&api_state).await
                                                })().await)
                        }
                })
    }
    fn wire_service_from_ptr_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,
            _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "service_from_ptr",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_ptr = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        {
                            transform_result_sse((move ||
                                            {
                                                Result::<_,
                                                        ()>::Ok(crate::api::api::service_from_ptr(api_ptr))
                                            })())
                        }
                })
    }
    fn wire_try_auth_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "try_auth",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_username = <String>::sse_decode(&mut deserializer);
                    let api_password = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::try_auth(&api_state, api_username,
                                                            api_password).await
                                                })().await)
                        }
                })
    }
    fn wire_upload_attachment_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "upload_attachment",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_sink =
                        <StreamSink<crate::api::api::TransferProgress,
                                flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_path = <String>::sse_decode(&mut deserializer);
                    let api_mime = <String>::sse_decode(&mut deserializer);
                    let api_uti = <String>::sse_decode(&mut deserializer);
                    let api_name = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::upload_attachment(api_sink, &api_state,
                                                            api_path, api_mime, api_uti, api_name).await
                                                })().await)
                        }
                })
    }
    fn wire_upload_mmcs_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "upload_mmcs",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_sink =
                        <StreamSink<crate::api::api::MMCSTransferProgress,
                                flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_path = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::upload_mmcs(api_sink, &api_state,
                                                            api_path).await
                                                })().await)
                        }
                })
    }
    fn wire_validate_targets_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "validate_targets",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_targets =
                        <Vec<String>>::sse_decode(&mut deserializer);
                    let api_sender = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::validate_targets(&api_state, api_targets,
                                                            api_sender).await
                                                })().await)
                        }
                })
    }
    fn wire_verify_2fa_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "verify_2fa",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_code = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    crate::api::api::verify_2fa(&api_state, api_code).await
                                                })().await)
                        }
                })
    }
    fn wire_verify_2fa_sms_impl(port_:
            flutter_rust_bridge::for_generated::MessagePort,
        ptr_:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len_: i32, data_len_: i32) {
        FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,
            _, _,
            _>(flutter_rust_bridge::for_generated::TaskInfo {
                debug_name: "verify_2fa_sms",
                port: Some(port_),
                mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
            },
            move ||
                {
                    let message =
                        unsafe {
                            flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                                rust_vec_len_, data_len_)
                        };
                    let mut deserializer =
                        flutter_rust_bridge::for_generated::SseDeserializer::new(message);
                    let api_state =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(&mut deserializer);
                    let api_body =
                        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>>::sse_decode(&mut deserializer);
                    let api_code = <String>::sse_decode(&mut deserializer);
                    deserializer.end();
                    move |context|
                        async move
                            {
                            transform_result_sse((move ||
                                                async move
                                                    {
                                                    let mut api_state_decoded = None;
                                                    let mut api_body_decoded = None;
                                                    let decode_indices_ =
                                                        flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([api_state.rust_auto_opaque_lock_order_info(0,
                                                                                false),
                                                                            api_body.rust_auto_opaque_lock_order_info(1, false)])));
                                                    for i in decode_indices_ {
                                                        match i {
                                                            0 =>
                                                                api_state_decoded =
                                                                    Some(api_state.rust_auto_opaque_decode_async_ref().await),
                                                            1 =>
                                                                api_body_decoded =
                                                                    Some(api_body.rust_auto_opaque_decode_async_ref().await),
                                                            _ =>
                                                                ::core::panicking::panic("internal error: entered unreachable code"),
                                                        }
                                                    }
                                                    let api_state = api_state_decoded.unwrap();
                                                    let api_body = api_body_decoded.unwrap();
                                                    crate::api::api::verify_2fa_sms(&api_state, &api_body,
                                                            api_code).await
                                                })().await)
                        }
                })
    }
    impl MoiArcValue for
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>
        {
        fn get_pool() -> &'static MoiArcPool<Self> {
            #[allow(missing_copy_implementations)]
            #[allow(non_camel_case_types)]
            #[allow(dead_code)]
            struct POOL {
                __private_field: (),
            }
            #[doc(hidden)]
            static POOL: POOL = POOL { __private_field: () };
            impl ::lazy_static::__Deref for POOL {
                type Target =
                    MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>;
                fn deref(&self)
                    ->
                        &MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>> {
                    #[inline(always)]
                    fn __static_ref_initialize()
                        ->
                            MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>> {
                        MoiArcPool::new(Default::default())
                    }
                    #[inline(always)]
                    fn __stability()
                        ->
                            &'static MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>> {
                        static LAZY:
                            ::lazy_static::lazy::Lazy<MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>
                            =
                            ::lazy_static::lazy::Lazy::INIT;
                        LAZY.get(__static_ref_initialize)
                    }
                    __stability()
                }
            }
            impl ::lazy_static::LazyStatic for POOL {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
            ;
            &POOL
        }
    }
    impl MoiArcValue for
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig> {
        fn get_pool() -> &'static MoiArcPool<Self> {
            #[allow(missing_copy_implementations)]
            #[allow(non_camel_case_types)]
            #[allow(dead_code)]
            struct POOL {
                __private_field: (),
            }
            #[doc(hidden)]
            static POOL: POOL = POOL { __private_field: () };
            impl ::lazy_static::__Deref for POOL {
                type Target =
                    MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>;
                fn deref(&self)
                    ->
                        &MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>> {
                    #[inline(always)]
                    fn __static_ref_initialize()
                        ->
                            MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>> {
                        MoiArcPool::new(Default::default())
                    }
                    #[inline(always)]
                    fn __stability()
                        ->
                            &'static MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>> {
                        static LAZY:
                            ::lazy_static::lazy::Lazy<MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>>
                            =
                            ::lazy_static::lazy::Lazy::INIT;
                        LAZY.get(__static_ref_initialize)
                    }
                    __stability()
                }
            }
            impl ::lazy_static::LazyStatic for POOL {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
            ;
            &POOL
        }
    }
    impl MoiArcValue for
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value> {
        fn get_pool() -> &'static MoiArcPool<Self> {
            #[allow(missing_copy_implementations)]
            #[allow(non_camel_case_types)]
            #[allow(dead_code)]
            struct POOL {
                __private_field: (),
            }
            #[doc(hidden)]
            static POOL: POOL = POOL { __private_field: () };
            impl ::lazy_static::__Deref for POOL {
                type Target =
                    MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>;
                fn deref(&self)
                    ->
                        &MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>> {
                    #[inline(always)]
                    fn __static_ref_initialize()
                        ->
                            MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>> {
                        MoiArcPool::new(Default::default())
                    }
                    #[inline(always)]
                    fn __stability()
                        ->
                            &'static MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>> {
                        static LAZY:
                            ::lazy_static::lazy::Lazy<MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>>
                            =
                            ::lazy_static::lazy::Lazy::INIT;
                        LAZY.get(__static_ref_initialize)
                    }
                    __stability()
                }
            }
            impl ::lazy_static::LazyStatic for POOL {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
            ;
            &POOL
        }
    }
    impl MoiArcValue for
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody> {
        fn get_pool() -> &'static MoiArcPool<Self> {
            #[allow(missing_copy_implementations)]
            #[allow(non_camel_case_types)]
            #[allow(dead_code)]
            struct POOL {
                __private_field: (),
            }
            #[doc(hidden)]
            static POOL: POOL = POOL { __private_field: () };
            impl ::lazy_static::__Deref for POOL {
                type Target =
                    MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>;
                fn deref(&self)
                    ->
                        &MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>> {
                    #[inline(always)]
                    fn __static_ref_initialize()
                        ->
                            MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>> {
                        MoiArcPool::new(Default::default())
                    }
                    #[inline(always)]
                    fn __stability()
                        ->
                            &'static MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>> {
                        static LAZY:
                            ::lazy_static::lazy::Lazy<MoiArcPool<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>>
                            =
                            ::lazy_static::lazy::Lazy::INIT;
                        LAZY.get(__static_ref_initialize)
                    }
                    __stability()
                }
            }
            impl ::lazy_static::LazyStatic for POOL {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
            ;
            &POOL
        }
    }
    impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            {
                ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                        format_args!("")));
            };
        }
    }
    impl SseDecode for Arc<PushState> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner =
                <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_decode(deserializer);
            return inner.rust_auto_opaque_decode_owned();
        }
    }
    impl SseDecode for MacOSConfig {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner =
                <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>>::sse_decode(deserializer);
            return inner.rust_auto_opaque_decode_owned();
        }
    }
    impl SseDecode for Value {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner =
                <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>>::sse_decode(deserializer);
            return inner.rust_auto_opaque_decode_owned();
        }
    }
    impl SseDecode for VerifyBody {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner =
                <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>>::sse_decode(deserializer);
            return inner.rust_auto_opaque_decode_owned();
        }
    }
    impl SseDecode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>
        {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <usize>::sse_decode(deserializer);
            return decode_rust_opaque_moi(inner);
        }
    }
    impl SseDecode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>
        {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <usize>::sse_decode(deserializer);
            return decode_rust_opaque_moi(inner);
        }
    }
    impl SseDecode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>
        {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <usize>::sse_decode(deserializer);
            return decode_rust_opaque_moi(inner);
        }
    }
    impl SseDecode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>
        {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <usize>::sse_decode(deserializer);
            return decode_rust_opaque_moi(inner);
        }
    }
    impl SseDecode for
        StreamSink<crate::api::api::MMCSTransferProgress,
        flutter_rust_bridge::for_generated::SseCodec> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <String>::sse_decode(deserializer);
            return StreamSink::deserialize(inner);
        }
    }
    impl SseDecode for
        StreamSink<crate::api::api::TransferProgress,
        flutter_rust_bridge::for_generated::SseCodec> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <String>::sse_decode(deserializer);
            return StreamSink::deserialize(inner);
        }
    }
    impl SseDecode for String {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <Vec<u8>>::sse_decode(deserializer);
            return String::from_utf8(inner).unwrap();
        }
    }
    impl SseDecode for bool {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_u8().unwrap() != 0
        }
    }
    impl SseDecode for crate::api::api::DartAttachment {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_aType =
                <crate::api::api::DartAttachmentType>::sse_decode(deserializer);
            let mut var_partIdx = <u64>::sse_decode(deserializer);
            let mut var_utiType = <String>::sse_decode(deserializer);
            let mut var_mime = <String>::sse_decode(deserializer);
            let mut var_name = <String>::sse_decode(deserializer);
            let mut var_iris = <bool>::sse_decode(deserializer);
            return crate::api::api::DartAttachment {
                    a_type: var_aType,
                    part_idx: var_partIdx,
                    uti_type: var_utiType,
                    mime: var_mime,
                    name: var_name,
                    iris: var_iris,
                };
        }
    }
    impl SseDecode for crate::api::api::DartAttachmentType {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                    return crate::api::api::DartAttachmentType::Inline(var_field0);
                }
                1 => {
                    let mut var_field0 =
                        <crate::api::api::DartMMCSFile>::sse_decode(deserializer);
                    return crate::api::api::DartAttachmentType::MMCS(var_field0);
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartBalloonBody {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_bid = <String>::sse_decode(deserializer);
            let mut var_data = <Vec<u8>>::sse_decode(deserializer);
            return crate::api::api::DartBalloonBody {
                    bid: var_bid,
                    data: var_data,
                };
        }
    }
    impl SseDecode for crate::api::api::DartChangeParticipantMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_newParticipants =
                <Vec<String>>::sse_decode(deserializer);
            let mut var_groupVersion = <u64>::sse_decode(deserializer);
            return crate::api::api::DartChangeParticipantMessage {
                    new_participants: var_newParticipants,
                    group_version: var_groupVersion,
                };
        }
    }
    impl SseDecode for crate::api::api::DartConversationData {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_participants =
                <Vec<String>>::sse_decode(deserializer);
            let mut var_cvName = <Option<String>>::sse_decode(deserializer);
            let mut var_senderGuid =
                <Option<String>>::sse_decode(deserializer);
            return crate::api::api::DartConversationData {
                    participants: var_participants,
                    cv_name: var_cvName,
                    sender_guid: var_senderGuid,
                };
        }
    }
    impl SseDecode for crate::api::api::DartDeviceInfo {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_name = <String>::sse_decode(deserializer);
            let mut var_serial = <String>::sse_decode(deserializer);
            let mut var_osVersion = <String>::sse_decode(deserializer);
            let mut var_encodedData = <Vec<u8>>::sse_decode(deserializer);
            return crate::api::api::DartDeviceInfo {
                    name: var_name,
                    serial: var_serial,
                    os_version: var_osVersion,
                    encoded_data: var_encodedData,
                };
        }
    }
    impl SseDecode for crate::api::api::DartEditMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_tuuid = <String>::sse_decode(deserializer);
            let mut var_editPart = <u64>::sse_decode(deserializer);
            let mut var_newParts =
                <crate::api::api::DartMessageParts>::sse_decode(deserializer);
            return crate::api::api::DartEditMessage {
                    tuuid: var_tuuid,
                    edit_part: var_editPart,
                    new_parts: var_newParts,
                };
        }
    }
    impl SseDecode for crate::api::api::DartHwExtra {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_version = <String>::sse_decode(deserializer);
            let mut var_protocolVersion = <u32>::sse_decode(deserializer);
            let mut var_deviceId = <String>::sse_decode(deserializer);
            let mut var_icloudUa = <String>::sse_decode(deserializer);
            let mut var_aoskitVersion = <String>::sse_decode(deserializer);
            return crate::api::api::DartHwExtra {
                    version: var_version,
                    protocol_version: var_protocolVersion,
                    device_id: var_deviceId,
                    icloud_ua: var_icloudUa,
                    aoskit_version: var_aoskitVersion,
                };
        }
    }
    impl SseDecode for crate::api::api::DartIMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_id = <String>::sse_decode(deserializer);
            let mut var_sender = <Option<String>>::sse_decode(deserializer);
            let mut var_afterGuid =
                <Option<String>>::sse_decode(deserializer);
            let mut var_conversation =
                <Option<crate::api::api::DartConversationData>>::sse_decode(deserializer);
            let mut var_message =
                <crate::api::api::DartMessage>::sse_decode(deserializer);
            let mut var_sentTimestamp = <u64>::sse_decode(deserializer);
            let mut var_target =
                <Option<Vec<crate::api::api::DartMessageTarget>>>::sse_decode(deserializer);
            let mut var_sendDelivered = <bool>::sse_decode(deserializer);
            return crate::api::api::DartIMessage {
                    id: var_id,
                    sender: var_sender,
                    after_guid: var_afterGuid,
                    conversation: var_conversation,
                    message: var_message,
                    sent_timestamp: var_sentTimestamp,
                    target: var_target,
                    send_delivered: var_sendDelivered,
                };
        }
    }
    impl SseDecode for crate::api::api::DartIconChangeMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_file =
                <Option<crate::api::api::DartMMCSFile>>::sse_decode(deserializer);
            let mut var_groupVersion = <u64>::sse_decode(deserializer);
            return crate::api::api::DartIconChangeMessage {
                    file: var_file,
                    group_version: var_groupVersion,
                };
        }
    }
    impl SseDecode for crate::api::api::DartIndexedMessagePart {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_part =
                <crate::api::api::DartMessagePart>::sse_decode(deserializer);
            let mut var_idx = <Option<usize>>::sse_decode(deserializer);
            let mut var_ext =
                <Option<crate::api::api::DartPartExtension>>::sse_decode(deserializer);
            return crate::api::api::DartIndexedMessagePart {
                    part: var_part,
                    idx: var_idx,
                    ext: var_ext,
                };
        }
    }
    impl SseDecode for crate::api::api::DartLoginState {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => { return crate::api::api::DartLoginState::LoggedIn; }
                1 => {
                    return crate::api::api::DartLoginState::NeedsDevice2FA;
                }
                2 => {
                    return crate::api::api::DartLoginState::Needs2FAVerification;
                }
                3 => { return crate::api::api::DartLoginState::NeedsSMS2FA; }
                4 => {
                    let mut var_field0 = <VerifyBody>::sse_decode(deserializer);
                    return crate::api::api::DartLoginState::NeedsSMS2FAVerification(var_field0);
                }
                5 => {
                    let mut var_field0 = <String>::sse_decode(deserializer);
                    return crate::api::api::DartLoginState::NeedsExtraStep(var_field0);
                }
                6 => { return crate::api::api::DartLoginState::NeedsLogin; }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    let mut var_field0 =
                        <crate::api::api::DartNormalMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::Message(var_field0);
                }
                1 => {
                    let mut var_field0 =
                        <crate::api::api::DartRenameMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::RenameMessage(var_field0);
                }
                2 => {
                    let mut var_field0 =
                        <crate::api::api::DartChangeParticipantMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::ChangeParticipants(var_field0);
                }
                3 => {
                    let mut var_field0 =
                        <crate::api::api::DartReactMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::React(var_field0);
                }
                4 => { return crate::api::api::DartMessage::Delivered; }
                5 => { return crate::api::api::DartMessage::Read; }
                6 => { return crate::api::api::DartMessage::Typing; }
                7 => {
                    let mut var_field0 =
                        <crate::api::api::DartUnsendMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::Unsend(var_field0);
                }
                8 => {
                    let mut var_field0 =
                        <crate::api::api::DartEditMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::Edit(var_field0);
                }
                9 => {
                    let mut var_field0 =
                        <crate::api::api::DartIconChangeMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::IconChange(var_field0);
                }
                10 => { return crate::api::api::DartMessage::StopTyping; }
                11 => {
                    let mut var_field0 = <bool>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::EnableSmsActivation(var_field0);
                }
                12 => {
                    return crate::api::api::DartMessage::MessageReadOnDevice;
                }
                13 => {
                    let mut var_field0 = <bool>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::SmsConfirmSent(var_field0);
                }
                14 => { return crate::api::api::DartMessage::MarkUnread; }
                15 => {
                    return crate::api::api::DartMessage::PeerCacheInvalidate;
                }
                16 => {
                    let mut var_field0 =
                        <crate::api::api::DartUpdateExtensionMessage>::sse_decode(deserializer);
                    return crate::api::api::DartMessage::UpdateExtension(var_field0);
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartMessagePart {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    let mut var_field0 = <String>::sse_decode(deserializer);
                    return crate::api::api::DartMessagePart::Text(var_field0);
                }
                1 => {
                    let mut var_field0 =
                        <crate::api::api::DartAttachment>::sse_decode(deserializer);
                    return crate::api::api::DartMessagePart::Attachment(var_field0);
                }
                2 => {
                    let mut var_field0 = <String>::sse_decode(deserializer);
                    let mut var_field1 = <String>::sse_decode(deserializer);
                    return crate::api::api::DartMessagePart::Mention(var_field0,
                            var_field1);
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartMessageParts {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_field0 =
                <Vec<crate::api::api::DartIndexedMessagePart>>::sse_decode(deserializer);
            return crate::api::api::DartMessageParts(var_field0);
        }
    }
    impl SseDecode for crate::api::api::DartMessageTarget {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                    return crate::api::api::DartMessageTarget::Token(var_field0);
                }
                1 => {
                    let mut var_field0 = <String>::sse_decode(deserializer);
                    return crate::api::api::DartMessageTarget::Uuid(var_field0);
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartMessageType {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => { return crate::api::api::DartMessageType::IMessage; }
                1 => {
                    let mut var_isPhone = <bool>::sse_decode(deserializer);
                    let mut var_usingNumber =
                        <String>::sse_decode(deserializer);
                    let mut var_fromHandle =
                        <Option<String>>::sse_decode(deserializer);
                    return crate::api::api::DartMessageType::SMS {
                            is_phone: var_isPhone,
                            using_number: var_usingNumber,
                            from_handle: var_fromHandle,
                        };
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartMMCSFile {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_signature = <Vec<u8>>::sse_decode(deserializer);
            let mut var_object = <String>::sse_decode(deserializer);
            let mut var_url = <String>::sse_decode(deserializer);
            let mut var_key = <Vec<u8>>::sse_decode(deserializer);
            let mut var_size = <usize>::sse_decode(deserializer);
            return crate::api::api::DartMMCSFile {
                    signature: var_signature,
                    object: var_object,
                    url: var_url,
                    key: var_key,
                    size: var_size,
                };
        }
    }
    impl SseDecode for crate::api::api::DartNormalMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_parts =
                <crate::api::api::DartMessageParts>::sse_decode(deserializer);
            let mut var_body =
                <Option<crate::api::api::DartBalloonBody>>::sse_decode(deserializer);
            let mut var_effect = <Option<String>>::sse_decode(deserializer);
            let mut var_replyGuid =
                <Option<String>>::sse_decode(deserializer);
            let mut var_replyPart =
                <Option<String>>::sse_decode(deserializer);
            let mut var_service =
                <crate::api::api::DartMessageType>::sse_decode(deserializer);
            return crate::api::api::DartNormalMessage {
                    parts: var_parts,
                    body: var_body,
                    effect: var_effect,
                    reply_guid: var_replyGuid,
                    reply_part: var_replyPart,
                    service: var_service,
                };
        }
    }
    impl SseDecode for crate::api::api::DartPartExtension {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    let mut var_msgWidth = <f64>::sse_decode(deserializer);
                    let mut var_rotation = <f64>::sse_decode(deserializer);
                    let mut var_sai = <u64>::sse_decode(deserializer);
                    let mut var_scale = <f64>::sse_decode(deserializer);
                    let mut var_update =
                        <Option<bool>>::sse_decode(deserializer);
                    let mut var_sli = <u64>::sse_decode(deserializer);
                    let mut var_normalizedX = <f64>::sse_decode(deserializer);
                    let mut var_normalizedY = <f64>::sse_decode(deserializer);
                    let mut var_version = <u64>::sse_decode(deserializer);
                    let mut var_hash = <String>::sse_decode(deserializer);
                    let mut var_safi = <u64>::sse_decode(deserializer);
                    let mut var_effectType = <i64>::sse_decode(deserializer);
                    let mut var_stickerId = <String>::sse_decode(deserializer);
                    return crate::api::api::DartPartExtension::Sticker {
                            msg_width: var_msgWidth,
                            rotation: var_rotation,
                            sai: var_sai,
                            scale: var_scale,
                            update: var_update,
                            sli: var_sli,
                            normalized_x: var_normalizedX,
                            normalized_y: var_normalizedY,
                            version: var_version,
                            hash: var_hash,
                            safi: var_safi,
                            effect_type: var_effectType,
                            sticker_id: var_stickerId,
                        };
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartPrivateDeviceInfo {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_uuid = <Option<String>>::sse_decode(deserializer);
            let mut var_deviceName =
                <Option<String>>::sse_decode(deserializer);
            let mut var_token = <Vec<u8>>::sse_decode(deserializer);
            let mut var_isHsaTrusted = <bool>::sse_decode(deserializer);
            let mut var_identites = <Vec<String>>::sse_decode(deserializer);
            let mut var_subServices = <Vec<String>>::sse_decode(deserializer);
            return crate::api::api::DartPrivateDeviceInfo {
                    uuid: var_uuid,
                    device_name: var_deviceName,
                    token: var_token,
                    is_hsa_trusted: var_isHsaTrusted,
                    identites: var_identites,
                    sub_services: var_subServices,
                };
        }
    }
    impl SseDecode for crate::api::api::DartReactMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_toUuid = <String>::sse_decode(deserializer);
            let mut var_toPart = <u64>::sse_decode(deserializer);
            let mut var_reaction =
                <crate::api::api::DartReactMessageType>::sse_decode(deserializer);
            let mut var_toText = <String>::sse_decode(deserializer);
            return crate::api::api::DartReactMessage {
                    to_uuid: var_toUuid,
                    to_part: var_toPart,
                    reaction: var_reaction,
                    to_text: var_toText,
                };
        }
    }
    impl SseDecode for crate::api::api::DartReactMessageType {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    let mut var_reaction =
                        <crate::api::api::DartReaction>::sse_decode(deserializer);
                    let mut var_enable = <bool>::sse_decode(deserializer);
                    return crate::api::api::DartReactMessageType::React {
                            reaction: var_reaction,
                            enable: var_enable,
                        };
                }
                1 => {
                    let mut var_spec = <Value>::sse_decode(deserializer);
                    let mut var_body =
                        <crate::api::api::DartMessageParts>::sse_decode(deserializer);
                    return crate::api::api::DartReactMessageType::Extension {
                            spec: var_spec,
                            body: var_body,
                        };
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartReaction {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <i32>::sse_decode(deserializer);
            return match inner {
                    0 => crate::api::api::DartReaction::Heart,
                    1 => crate::api::api::DartReaction::Like,
                    2 => crate::api::api::DartReaction::Dislike,
                    3 => crate::api::api::DartReaction::Laugh,
                    4 => crate::api::api::DartReaction::Emphsize,
                    5 => crate::api::api::DartReaction::Question,
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("Invalid variant for DartReaction: {0}",
                                    inner)));
                    }
                };
        }
    }
    impl SseDecode for crate::api::api::DartRegisterState {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => {
                    return crate::api::api::DartRegisterState::Registered;
                }
                1 => {
                    return crate::api::api::DartRegisterState::Registering;
                }
                2 => {
                    let mut var_retryWait =
                        <Option<u64>>::sse_decode(deserializer);
                    let mut var_error = <String>::sse_decode(deserializer);
                    return crate::api::api::DartRegisterState::Failed {
                            retry_wait: var_retryWait,
                            error: var_error,
                        };
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for crate::api::api::DartRenameMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_newName = <String>::sse_decode(deserializer);
            return crate::api::api::DartRenameMessage {
                    new_name: var_newName,
                };
        }
    }
    impl SseDecode for crate::api::api::DartSupportAction {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_url = <String>::sse_decode(deserializer);
            let mut var_button = <String>::sse_decode(deserializer);
            return crate::api::api::DartSupportAction {
                    url: var_url,
                    button: var_button,
                };
        }
    }
    impl SseDecode for crate::api::api::DartSupportAlert {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_title = <String>::sse_decode(deserializer);
            let mut var_body = <String>::sse_decode(deserializer);
            let mut var_action =
                <Option<crate::api::api::DartSupportAction>>::sse_decode(deserializer);
            return crate::api::api::DartSupportAlert {
                    title: var_title,
                    body: var_body,
                    action: var_action,
                };
        }
    }
    impl SseDecode for crate::api::api::DartTrustedPhoneNumber {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_numberWithDialCode =
                <String>::sse_decode(deserializer);
            let mut var_lastTwoDigits = <String>::sse_decode(deserializer);
            let mut var_pushMode = <String>::sse_decode(deserializer);
            let mut var_id = <u32>::sse_decode(deserializer);
            return crate::api::api::DartTrustedPhoneNumber {
                    number_with_dial_code: var_numberWithDialCode,
                    last_two_digits: var_lastTwoDigits,
                    push_mode: var_pushMode,
                    id: var_id,
                };
        }
    }
    impl SseDecode for crate::api::api::DartUnsendMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_tuuid = <String>::sse_decode(deserializer);
            let mut var_editPart = <u64>::sse_decode(deserializer);
            return crate::api::api::DartUnsendMessage {
                    tuuid: var_tuuid,
                    edit_part: var_editPart,
                };
        }
    }
    impl SseDecode for crate::api::api::DartUpdateExtensionMessage {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_forUuid = <String>::sse_decode(deserializer);
            let mut var_ext =
                <crate::api::api::DartPartExtension>::sse_decode(deserializer);
            return crate::api::api::DartUpdateExtensionMessage {
                    for_uuid: var_forUuid,
                    ext: var_ext,
                };
        }
    }
    impl SseDecode for f64 {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_f64::<NativeEndian>().unwrap()
        }
    }
    impl SseDecode for i32 {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_i32::<NativeEndian>().unwrap()
        }
    }
    impl SseDecode for i64 {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_i64::<NativeEndian>().unwrap()
        }
    }
    impl SseDecode for Vec<String> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut len_ = <i32>::sse_decode(deserializer);
            let mut ans_ = ::alloc::vec::Vec::new();
            for idx_ in 0..len_ {
                ans_.push(<String>::sse_decode(deserializer));
            }
            return ans_;
        }
    }
    impl SseDecode for Vec<crate::api::api::DartIndexedMessagePart> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut len_ = <i32>::sse_decode(deserializer);
            let mut ans_ = ::alloc::vec::Vec::new();
            for idx_ in 0..len_ {
                ans_.push(<crate::api::api::DartIndexedMessagePart>::sse_decode(deserializer));
            }
            return ans_;
        }
    }
    impl SseDecode for Vec<crate::api::api::DartMessageTarget> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut len_ = <i32>::sse_decode(deserializer);
            let mut ans_ = ::alloc::vec::Vec::new();
            for idx_ in 0..len_ {
                ans_.push(<crate::api::api::DartMessageTarget>::sse_decode(deserializer));
            }
            return ans_;
        }
    }
    impl SseDecode for Vec<crate::api::api::DartPrivateDeviceInfo> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut len_ = <i32>::sse_decode(deserializer);
            let mut ans_ = ::alloc::vec::Vec::new();
            for idx_ in 0..len_ {
                ans_.push(<crate::api::api::DartPrivateDeviceInfo>::sse_decode(deserializer));
            }
            return ans_;
        }
    }
    impl SseDecode for Vec<crate::api::api::DartTrustedPhoneNumber> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut len_ = <i32>::sse_decode(deserializer);
            let mut ans_ = ::alloc::vec::Vec::new();
            for idx_ in 0..len_ {
                ans_.push(<crate::api::api::DartTrustedPhoneNumber>::sse_decode(deserializer));
            }
            return ans_;
        }
    }
    impl SseDecode for Vec<u8> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut len_ = <i32>::sse_decode(deserializer);
            let mut ans_ = ::alloc::vec::Vec::new();
            for idx_ in 0..len_ { ans_.push(<u8>::sse_decode(deserializer)); }
            return ans_;
        }
    }
    impl SseDecode for crate::api::api::MMCSTransferProgress {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_prog = <usize>::sse_decode(deserializer);
            let mut var_total = <usize>::sse_decode(deserializer);
            let mut var_file =
                <Option<crate::api::api::DartMMCSFile>>::sse_decode(deserializer);
            return crate::api::api::MMCSTransferProgress {
                    prog: var_prog,
                    total: var_total,
                    file: var_file,
                };
        }
    }
    impl SseDecode for Option<String> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<String>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<bool> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<bool>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartAttachment> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartAttachment>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartBalloonBody> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartBalloonBody>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartConversationData> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartConversationData>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartIMessage> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartIMessage>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartLoginState> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartLoginState>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartMMCSFile> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartMMCSFile>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartPartExtension> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartPartExtension>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartSupportAction> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartSupportAction>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<crate::api::api::DartSupportAlert> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<crate::api::api::DartSupportAlert>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<u64> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<u64>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<usize> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<usize>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for Option<Vec<crate::api::api::DartMessageTarget>> {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            if (<bool>::sse_decode(deserializer)) {
                    return Some(<Vec<crate::api::api::DartMessageTarget>>::sse_decode(deserializer));
                } else { return None; }
        }
    }
    impl SseDecode for crate::api::api::PollResult {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut tag_ = <i32>::sse_decode(deserializer);
            match tag_ {
                0 => { return crate::api::api::PollResult::Stop; }
                1 => {
                    let mut var_field0 =
                        <Option<crate::api::api::DartIMessage>>::sse_decode(deserializer);
                    return crate::api::api::PollResult::Cont(var_field0);
                }
                _ => {
                    {
                        ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                format_args!("")));
                    };
                }
            }
        }
    }
    impl SseDecode for
        (Vec<crate::api::api::DartTrustedPhoneNumber>,
        Option<crate::api::api::DartLoginState>) {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_field0 =
                <Vec<crate::api::api::DartTrustedPhoneNumber>>::sse_decode(deserializer);
            let mut var_field1 =
                <Option<crate::api::api::DartLoginState>>::sse_decode(deserializer);
            return (var_field0, var_field1);
        }
    }
    impl SseDecode for crate::api::api::RegistrationPhase {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut inner = <i32>::sse_decode(deserializer);
            return match inner {
                    0 => crate::api::api::RegistrationPhase::WantsOSConfig,
                    1 => crate::api::api::RegistrationPhase::WantsUserPass,
                    2 => crate::api::api::RegistrationPhase::WantsRegister,
                    3 => crate::api::api::RegistrationPhase::Registered,
                    _ => {
                        ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                format_args!("Invalid variant for RegistrationPhase: {0}",
                                    inner)));
                    }
                };
        }
    }
    impl SseDecode for crate::api::api::TransferProgress {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            let mut var_prog = <usize>::sse_decode(deserializer);
            let mut var_total = <usize>::sse_decode(deserializer);
            let mut var_attachment =
                <Option<crate::api::api::DartAttachment>>::sse_decode(deserializer);
            return crate::api::api::TransferProgress {
                    prog: var_prog,
                    total: var_total,
                    attachment: var_attachment,
                };
        }
    }
    impl SseDecode for u32 {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_u32::<NativeEndian>().unwrap()
        }
    }
    impl SseDecode for u64 {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_u64::<NativeEndian>().unwrap()
        }
    }
    impl SseDecode for u8 {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_u8().unwrap()
        }
    }
    impl SseDecode for () {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {}
    }
    impl SseDecode for usize {
        fn sse_decode(deserializer:
                &mut flutter_rust_bridge::for_generated::SseDeserializer)
            -> Self {
            deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
        }
    }
    fn pde_ffi_dispatcher_primary_impl(func_id: i32,
        port: flutter_rust_bridge::for_generated::MessagePort,
        ptr:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len: i32, data_len: i32) {
        match func_id {
            8 =>
                wire_config_from_encoded_impl(port, ptr, rust_vec_len,
                    data_len),
            5 =>
                wire_config_from_validation_data_impl(port, ptr, rust_vec_len,
                    data_len),
            4 => wire_configure_macos_impl(port, ptr, rust_vec_len, data_len),
            31 =>
                wire_convert_token_to_uuid_impl(port, ptr, rust_vec_len,
                    data_len),
            35 =>
                wire_dart_attachment_get_size_impl(port, ptr, rust_vec_len,
                    data_len),
            34 =>
                wire_dart_attachment_restore_impl(port, ptr, rust_vec_len,
                    data_len),
            33 =>
                wire_dart_attachment_save_impl(port, ptr, rust_vec_len,
                    data_len),
            36 =>
                wire_dart_message_parts_as_plain_impl(port, ptr, rust_vec_len,
                    data_len),
            13 => wire_do_reregister_impl(port, ptr, rust_vec_len, data_len),
            17 =>
                wire_download_attachment_impl(port, ptr, rust_vec_len,
                    data_len),
            18 => wire_download_mmcs_impl(port, ptr, rust_vec_len, data_len),
            24 =>
                wire_get_2fa_sms_opts_impl(port, ptr, rust_vec_len, data_len),
            7 => wire_get_device_info_impl(port, ptr, rust_vec_len, data_len),
            6 =>
                wire_get_device_info_state_impl(port, ptr, rust_vec_len,
                    data_len),
            12 => wire_get_handles_impl(port, ptr, rust_vec_len, data_len),
            16 => wire_get_phase_impl(port, ptr, rust_vec_len, data_len),
            30 => wire_get_regstate_impl(port, ptr, rust_vec_len, data_len),
            32 =>
                wire_get_sms_targets_impl(port, ptr, rust_vec_len, data_len),
            29 => wire_get_user_name_impl(port, ptr, rust_vec_len, data_len),
            28 =>
                wire_invalidate_id_cache_impl(port, ptr, rust_vec_len,
                    data_len),
            14 => wire_new_msg_impl(port, ptr, rust_vec_len, data_len),
            1 => wire_new_push_state_impl(port, ptr, rust_vec_len, data_len),
            9 => wire_ptr_to_dart_impl(port, ptr, rust_vec_len, data_len),
            10 => wire_recv_wait_impl(port, ptr, rust_vec_len, data_len),
            3 => wire_register_ids_impl(port, ptr, rust_vec_len, data_len),
            27 => wire_reset_state_impl(port, ptr, rust_vec_len, data_len),
            11 => wire_send_impl(port, ptr, rust_vec_len, data_len),
            25 => wire_send_2fa_sms_impl(port, ptr, rust_vec_len, data_len),
            22 =>
                wire_send_2fa_to_devices_impl(port, ptr, rust_vec_len,
                    data_len),
            2 =>
                wire_service_from_ptr_impl(port, ptr, rust_vec_len, data_len),
            21 => wire_try_auth_impl(port, ptr, rust_vec_len, data_len),
            20 =>
                wire_upload_attachment_impl(port, ptr, rust_vec_len,
                    data_len),
            19 => wire_upload_mmcs_impl(port, ptr, rust_vec_len, data_len),
            15 =>
                wire_validate_targets_impl(port, ptr, rust_vec_len, data_len),
            23 => wire_verify_2fa_impl(port, ptr, rust_vec_len, data_len),
            26 => wire_verify_2fa_sms_impl(port, ptr, rust_vec_len, data_len),
            _ =>
                ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
    fn pde_ffi_dispatcher_sync_impl(func_id: i32,
        ptr:
            flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
        rust_vec_len: i32, data_len: i32)
        -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
        match func_id {
            _ =>
                ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
    impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<PushState>> {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self.0).into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        FrbWrapper<Arc<PushState>> {}
    impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<PushState>>> for
        Arc<PushState> {
        fn into_into_dart(self) -> FrbWrapper<Arc<PushState>> { self.into() }
    }
    impl flutter_rust_bridge::IntoDart for FrbWrapper<MacOSConfig> {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self.0).into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        FrbWrapper<MacOSConfig> {}
    impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MacOSConfig>> for
        MacOSConfig {
        fn into_into_dart(self) -> FrbWrapper<MacOSConfig> { self.into() }
    }
    impl flutter_rust_bridge::IntoDart for FrbWrapper<Value> {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self.0).into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        FrbWrapper<Value> {}
    impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Value>> for Value {
        fn into_into_dart(self) -> FrbWrapper<Value> { self.into() }
    }
    impl flutter_rust_bridge::IntoDart for FrbWrapper<VerifyBody> {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self.0).into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        FrbWrapper<VerifyBody> {}
    impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<VerifyBody>> for
        VerifyBody {
        fn into_into_dart(self) -> FrbWrapper<VerifyBody> { self.into() }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartAttachment {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.a_type.into_into_dart().into_dart(),
                        self.part_idx.into_into_dart().into_dart(),
                        self.uti_type.into_into_dart().into_dart(),
                        self.mime.into_into_dart().into_dart(),
                        self.name.into_into_dart().into_dart(),
                        self.iris.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartAttachment {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartAttachment>
        for crate::api::api::DartAttachment {
        fn into_into_dart(self) -> crate::api::api::DartAttachment { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartAttachmentType
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartAttachmentType::Inline(field0) => {
                    [0.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartAttachmentType::MMCS(field0) => {
                    [1.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartAttachmentType {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartAttachmentType>
        for crate::api::api::DartAttachmentType {
        fn into_into_dart(self) -> crate::api::api::DartAttachmentType {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartBalloonBody {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.bid.into_into_dart().into_dart(),
                        self.data.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartBalloonBody {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartBalloonBody>
        for crate::api::api::DartBalloonBody {
        fn into_into_dart(self) -> crate::api::api::DartBalloonBody { self }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartChangeParticipantMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.new_participants.into_into_dart().into_dart(),
                        self.group_version.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartChangeParticipantMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartChangeParticipantMessage>
        for crate::api::api::DartChangeParticipantMessage {
        fn into_into_dart(self)
            -> crate::api::api::DartChangeParticipantMessage {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartConversationData {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.participants.into_into_dart().into_dart(),
                        self.cv_name.into_into_dart().into_dart(),
                        self.sender_guid.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartConversationData {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartConversationData>
        for crate::api::api::DartConversationData {
        fn into_into_dart(self) -> crate::api::api::DartConversationData {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartDeviceInfo {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.name.into_into_dart().into_dart(),
                        self.serial.into_into_dart().into_dart(),
                        self.os_version.into_into_dart().into_dart(),
                        self.encoded_data.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartDeviceInfo {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartDeviceInfo>
        for crate::api::api::DartDeviceInfo {
        fn into_into_dart(self) -> crate::api::api::DartDeviceInfo { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartEditMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.tuuid.into_into_dart().into_dart(),
                        self.edit_part.into_into_dart().into_dart(),
                        self.new_parts.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartEditMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartEditMessage>
        for crate::api::api::DartEditMessage {
        fn into_into_dart(self) -> crate::api::api::DartEditMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartHwExtra {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.version.into_into_dart().into_dart(),
                        self.protocol_version.into_into_dart().into_dart(),
                        self.device_id.into_into_dart().into_dart(),
                        self.icloud_ua.into_into_dart().into_dart(),
                        self.aoskit_version.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartHwExtra {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartHwExtra> for
        crate::api::api::DartHwExtra {
        fn into_into_dart(self) -> crate::api::api::DartHwExtra { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartIMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.id.into_into_dart().into_dart(),
                        self.sender.into_into_dart().into_dart(),
                        self.after_guid.into_into_dart().into_dart(),
                        self.conversation.into_into_dart().into_dart(),
                        self.message.into_into_dart().into_dart(),
                        self.sent_timestamp.into_into_dart().into_dart(),
                        self.target.into_into_dart().into_dart(),
                        self.send_delivered.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartIMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartIMessage> for
        crate::api::api::DartIMessage {
        fn into_into_dart(self) -> crate::api::api::DartIMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartIconChangeMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.file.into_into_dart().into_dart(),
                        self.group_version.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartIconChangeMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartIconChangeMessage>
        for crate::api::api::DartIconChangeMessage {
        fn into_into_dart(self) -> crate::api::api::DartIconChangeMessage {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartIndexedMessagePart {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.part.into_into_dart().into_dart(),
                        self.idx.into_into_dart().into_dart(),
                        self.ext.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartIndexedMessagePart {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartIndexedMessagePart>
        for crate::api::api::DartIndexedMessagePart {
        fn into_into_dart(self) -> crate::api::api::DartIndexedMessagePart {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartLoginState {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartLoginState::LoggedIn => {
                    [0.into_dart()].into_dart()
                }
                crate::api::api::DartLoginState::NeedsDevice2FA => {
                    [1.into_dart()].into_dart()
                }
                crate::api::api::DartLoginState::Needs2FAVerification => {
                    [2.into_dart()].into_dart()
                }
                crate::api::api::DartLoginState::NeedsSMS2FA => {
                    [3.into_dart()].into_dart()
                }
                crate::api::api::DartLoginState::NeedsSMS2FAVerification(field0)
                    => {
                    [4.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartLoginState::NeedsExtraStep(field0) => {
                    [5.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartLoginState::NeedsLogin => {
                    [6.into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartLoginState {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartLoginState>
        for crate::api::api::DartLoginState {
        fn into_into_dart(self) -> crate::api::api::DartLoginState { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartMessage::Message(field0) => {
                    [0.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::RenameMessage(field0) => {
                    [1.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::ChangeParticipants(field0) => {
                    [2.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::React(field0) => {
                    [3.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::Delivered => {
                    [4.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::Read => {
                    [5.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::Typing => {
                    [6.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::Unsend(field0) => {
                    [7.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::Edit(field0) => {
                    [8.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::IconChange(field0) => {
                    [9.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::StopTyping => {
                    [10.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::EnableSmsActivation(field0) => {
                    [11.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::MessageReadOnDevice => {
                    [12.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::SmsConfirmSent(field0) => {
                    [13.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessage::MarkUnread => {
                    [14.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::PeerCacheInvalidate => {
                    [15.into_dart()].into_dart()
                }
                crate::api::api::DartMessage::UpdateExtension(field0) => {
                    [16.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartMessage> for
        crate::api::api::DartMessage {
        fn into_into_dart(self) -> crate::api::api::DartMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartMessagePart {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartMessagePart::Text(field0) => {
                    [0.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessagePart::Attachment(field0) => {
                    [1.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessagePart::Mention(field0, field1) => {
                    [2.into_dart(), field0.into_into_dart().into_dart(),
                                field1.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartMessagePart {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartMessagePart>
        for crate::api::api::DartMessagePart {
        fn into_into_dart(self) -> crate::api::api::DartMessagePart { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartMessageParts {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.0.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartMessageParts {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartMessageParts>
        for crate::api::api::DartMessageParts {
        fn into_into_dart(self) -> crate::api::api::DartMessageParts { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartMessageTarget
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartMessageTarget::Token(field0) => {
                    [0.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartMessageTarget::Uuid(field0) => {
                    [1.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartMessageTarget {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartMessageTarget>
        for crate::api::api::DartMessageTarget {
        fn into_into_dart(self) -> crate::api::api::DartMessageTarget { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartMessageType {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartMessageType::IMessage => {
                    [0.into_dart()].into_dart()
                }
                crate::api::api::DartMessageType::SMS {
                    is_phone, using_number, from_handle } => {
                    [1.into_dart(), is_phone.into_into_dart().into_dart(),
                                using_number.into_into_dart().into_dart(),
                                from_handle.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartMessageType {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartMessageType>
        for crate::api::api::DartMessageType {
        fn into_into_dart(self) -> crate::api::api::DartMessageType { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartMMCSFile {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.signature.into_into_dart().into_dart(),
                        self.object.into_into_dart().into_dart(),
                        self.url.into_into_dart().into_dart(),
                        self.key.into_into_dart().into_dart(),
                        self.size.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartMMCSFile {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartMMCSFile> for
        crate::api::api::DartMMCSFile {
        fn into_into_dart(self) -> crate::api::api::DartMMCSFile { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartNormalMessage
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.parts.into_into_dart().into_dart(),
                        self.body.into_into_dart().into_dart(),
                        self.effect.into_into_dart().into_dart(),
                        self.reply_guid.into_into_dart().into_dart(),
                        self.reply_part.into_into_dart().into_dart(),
                        self.service.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartNormalMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartNormalMessage>
        for crate::api::api::DartNormalMessage {
        fn into_into_dart(self) -> crate::api::api::DartNormalMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartPartExtension
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartPartExtension::Sticker {
                    msg_width,
                    rotation,
                    sai,
                    scale,
                    update,
                    sli,
                    normalized_x,
                    normalized_y,
                    version,
                    hash,
                    safi,
                    effect_type,
                    sticker_id } => {
                    [0.into_dart(), msg_width.into_into_dart().into_dart(),
                                rotation.into_into_dart().into_dart(),
                                sai.into_into_dart().into_dart(),
                                scale.into_into_dart().into_dart(),
                                update.into_into_dart().into_dart(),
                                sli.into_into_dart().into_dart(),
                                normalized_x.into_into_dart().into_dart(),
                                normalized_y.into_into_dart().into_dart(),
                                version.into_into_dart().into_dart(),
                                hash.into_into_dart().into_dart(),
                                safi.into_into_dart().into_dart(),
                                effect_type.into_into_dart().into_dart(),
                                sticker_id.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartPartExtension {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartPartExtension>
        for crate::api::api::DartPartExtension {
        fn into_into_dart(self) -> crate::api::api::DartPartExtension { self }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartPrivateDeviceInfo {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.uuid.into_into_dart().into_dart(),
                        self.device_name.into_into_dart().into_dart(),
                        self.token.into_into_dart().into_dart(),
                        self.is_hsa_trusted.into_into_dart().into_dart(),
                        self.identites.into_into_dart().into_dart(),
                        self.sub_services.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartPrivateDeviceInfo {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartPrivateDeviceInfo>
        for crate::api::api::DartPrivateDeviceInfo {
        fn into_into_dart(self) -> crate::api::api::DartPrivateDeviceInfo {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartReactMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.to_uuid.into_into_dart().into_dart(),
                        self.to_part.into_into_dart().into_dart(),
                        self.reaction.into_into_dart().into_dart(),
                        self.to_text.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartReactMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartReactMessage>
        for crate::api::api::DartReactMessage {
        fn into_into_dart(self) -> crate::api::api::DartReactMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartReactMessageType {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartReactMessageType::React {
                    reaction, enable } => {
                    [0.into_dart(), reaction.into_into_dart().into_dart(),
                                enable.into_into_dart().into_dart()].into_dart()
                }
                crate::api::api::DartReactMessageType::Extension { spec, body
                    } => {
                    [1.into_dart(), spec.into_into_dart().into_dart(),
                                body.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartReactMessageType {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartReactMessageType>
        for crate::api::api::DartReactMessageType {
        fn into_into_dart(self) -> crate::api::api::DartReactMessageType {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartReaction {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                Self::Heart => 0.into_dart(),
                Self::Like => 1.into_dart(),
                Self::Dislike => 2.into_dart(),
                Self::Laugh => 3.into_dart(),
                Self::Emphsize => 4.into_dart(),
                Self::Question => 5.into_dart(),
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartReaction {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartReaction> for
        crate::api::api::DartReaction {
        fn into_into_dart(self) -> crate::api::api::DartReaction { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartRegisterState
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::DartRegisterState::Registered => {
                    [0.into_dart()].into_dart()
                }
                crate::api::api::DartRegisterState::Registering => {
                    [1.into_dart()].into_dart()
                }
                crate::api::api::DartRegisterState::Failed { retry_wait, error
                    } => {
                    [2.into_dart(), retry_wait.into_into_dart().into_dart(),
                                error.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartRegisterState {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartRegisterState>
        for crate::api::api::DartRegisterState {
        fn into_into_dart(self) -> crate::api::api::DartRegisterState { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartRenameMessage
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.new_name.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartRenameMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartRenameMessage>
        for crate::api::api::DartRenameMessage {
        fn into_into_dart(self) -> crate::api::api::DartRenameMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartSupportAction
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.url.into_into_dart().into_dart(),
                        self.button.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartSupportAction {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartSupportAction>
        for crate::api::api::DartSupportAction {
        fn into_into_dart(self) -> crate::api::api::DartSupportAction { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartSupportAlert {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.title.into_into_dart().into_dart(),
                        self.body.into_into_dart().into_dart(),
                        self.action.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartSupportAlert {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartSupportAlert>
        for crate::api::api::DartSupportAlert {
        fn into_into_dart(self) -> crate::api::api::DartSupportAlert { self }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartTrustedPhoneNumber {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.number_with_dial_code.into_into_dart().into_dart(),
                        self.last_two_digits.into_into_dart().into_dart(),
                        self.push_mode.into_into_dart().into_dart(),
                        self.id.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartTrustedPhoneNumber {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartTrustedPhoneNumber>
        for crate::api::api::DartTrustedPhoneNumber {
        fn into_into_dart(self) -> crate::api::api::DartTrustedPhoneNumber {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::DartUnsendMessage
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.tuuid.into_into_dart().into_dart(),
                        self.edit_part.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartUnsendMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartUnsendMessage>
        for crate::api::api::DartUnsendMessage {
        fn into_into_dart(self) -> crate::api::api::DartUnsendMessage { self }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::DartUpdateExtensionMessage {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.for_uuid.into_into_dart().into_dart(),
                        self.ext.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::DartUpdateExtensionMessage {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::DartUpdateExtensionMessage>
        for crate::api::api::DartUpdateExtensionMessage {
        fn into_into_dart(self)
            -> crate::api::api::DartUpdateExtensionMessage {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for
        crate::api::api::MMCSTransferProgress {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.prog.into_into_dart().into_dart(),
                        self.total.into_into_dart().into_dart(),
                        self.file.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::MMCSTransferProgress {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::MMCSTransferProgress>
        for crate::api::api::MMCSTransferProgress {
        fn into_into_dart(self) -> crate::api::api::MMCSTransferProgress {
            self
        }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::PollResult {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                crate::api::api::PollResult::Stop => {
                    [0.into_dart()].into_dart()
                }
                crate::api::api::PollResult::Cont(field0) => {
                    [1.into_dart(),
                                field0.into_into_dart().into_dart()].into_dart()
                }
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::PollResult {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::PollResult> for
        crate::api::api::PollResult {
        fn into_into_dart(self) -> crate::api::api::PollResult { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::RegistrationPhase
        {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            match self {
                Self::WantsOSConfig => 0.into_dart(),
                Self::WantsUserPass => 1.into_dart(),
                Self::WantsRegister => 2.into_dart(),
                Self::Registered => 3.into_dart(),
            }
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::RegistrationPhase {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::RegistrationPhase>
        for crate::api::api::RegistrationPhase {
        fn into_into_dart(self) -> crate::api::api::RegistrationPhase { self }
    }
    impl flutter_rust_bridge::IntoDart for crate::api::api::TransferProgress {
        fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
            [self.prog.into_into_dart().into_dart(),
                        self.total.into_into_dart().into_dart(),
                        self.attachment.into_into_dart().into_dart()].into_dart()
        }
    }
    impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for
        crate::api::api::TransferProgress {}
    impl flutter_rust_bridge::IntoIntoDart<crate::api::api::TransferProgress>
        for crate::api::api::TransferProgress {
        fn into_into_dart(self) -> crate::api::api::TransferProgress { self }
    }
    impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode({
                    let res = ::alloc::fmt::format(format_args!("{0:?}", self));
                    res
                }, serializer);
        }
    }
    impl SseEncode for Arc<PushState> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self), serializer);
        }
    }
    impl SseEncode for MacOSConfig {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self), serializer);
        }
    }
    impl SseEncode for Value {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self), serializer);
        }
    }
    impl SseEncode for VerifyBody {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_,
                        MoiArc<_>>(self), serializer);
        }
    }
    impl SseEncode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>
        {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            let (ptr, size) = self.sse_encode_raw();
            <usize>::sse_encode(ptr, serializer);
            <i32>::sse_encode(size, serializer);
        }
    }
    impl SseEncode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>
        {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            let (ptr, size) = self.sse_encode_raw();
            <usize>::sse_encode(ptr, serializer);
            <i32>::sse_encode(size, serializer);
        }
    }
    impl SseEncode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>
        {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            let (ptr, size) = self.sse_encode_raw();
            <usize>::sse_encode(ptr, serializer);
            <i32>::sse_encode(size, serializer);
        }
    }
    impl SseEncode for
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>
        {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            let (ptr, size) = self.sse_encode_raw();
            <usize>::sse_encode(ptr, serializer);
            <i32>::sse_encode(size, serializer);
        }
    }
    impl SseEncode for
        StreamSink<crate::api::api::MMCSTransferProgress,
        flutter_rust_bridge::for_generated::SseCodec> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            {
                ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                        format_args!("")));
            }
        }
    }
    impl SseEncode for
        StreamSink<crate::api::api::TransferProgress,
        flutter_rust_bridge::for_generated::SseCodec> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            {
                ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                        format_args!("")));
            }
        }
    }
    impl SseEncode for String {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
        }
    }
    impl SseEncode for bool {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_u8(self as _).unwrap();
        }
    }
    impl SseEncode for crate::api::api::DartAttachment {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <crate::api::api::DartAttachmentType>::sse_encode(self.a_type,
                serializer);
            <u64>::sse_encode(self.part_idx, serializer);
            <String>::sse_encode(self.uti_type, serializer);
            <String>::sse_encode(self.mime, serializer);
            <String>::sse_encode(self.name, serializer);
            <bool>::sse_encode(self.iris, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartAttachmentType {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartAttachmentType::Inline(field0) => {
                    <i32>::sse_encode(0, serializer);
                    <Vec<u8>>::sse_encode(field0, serializer);
                }
                crate::api::api::DartAttachmentType::MMCS(field0) => {
                    <i32>::sse_encode(1, serializer);
                    <crate::api::api::DartMMCSFile>::sse_encode(field0,
                        serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartBalloonBody {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.bid, serializer);
            <Vec<u8>>::sse_encode(self.data, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartChangeParticipantMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Vec<String>>::sse_encode(self.new_participants, serializer);
            <u64>::sse_encode(self.group_version, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartConversationData {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Vec<String>>::sse_encode(self.participants, serializer);
            <Option<String>>::sse_encode(self.cv_name, serializer);
            <Option<String>>::sse_encode(self.sender_guid, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartDeviceInfo {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.name, serializer);
            <String>::sse_encode(self.serial, serializer);
            <String>::sse_encode(self.os_version, serializer);
            <Vec<u8>>::sse_encode(self.encoded_data, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartEditMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.tuuid, serializer);
            <u64>::sse_encode(self.edit_part, serializer);
            <crate::api::api::DartMessageParts>::sse_encode(self.new_parts,
                serializer);
        }
    }
    impl SseEncode for crate::api::api::DartHwExtra {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.version, serializer);
            <u32>::sse_encode(self.protocol_version, serializer);
            <String>::sse_encode(self.device_id, serializer);
            <String>::sse_encode(self.icloud_ua, serializer);
            <String>::sse_encode(self.aoskit_version, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartIMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.id, serializer);
            <Option<String>>::sse_encode(self.sender, serializer);
            <Option<String>>::sse_encode(self.after_guid, serializer);
            <Option<crate::api::api::DartConversationData>>::sse_encode(self.conversation,
                serializer);
            <crate::api::api::DartMessage>::sse_encode(self.message,
                serializer);
            <u64>::sse_encode(self.sent_timestamp, serializer);
            <Option<Vec<crate::api::api::DartMessageTarget>>>::sse_encode(self.target,
                serializer);
            <bool>::sse_encode(self.send_delivered, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartIconChangeMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Option<crate::api::api::DartMMCSFile>>::sse_encode(self.file,
                serializer);
            <u64>::sse_encode(self.group_version, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartIndexedMessagePart {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <crate::api::api::DartMessagePart>::sse_encode(self.part,
                serializer);
            <Option<usize>>::sse_encode(self.idx, serializer);
            <Option<crate::api::api::DartPartExtension>>::sse_encode(self.ext,
                serializer);
        }
    }
    impl SseEncode for crate::api::api::DartLoginState {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartLoginState::LoggedIn => {
                    <i32>::sse_encode(0, serializer);
                }
                crate::api::api::DartLoginState::NeedsDevice2FA => {
                    <i32>::sse_encode(1, serializer);
                }
                crate::api::api::DartLoginState::Needs2FAVerification => {
                    <i32>::sse_encode(2, serializer);
                }
                crate::api::api::DartLoginState::NeedsSMS2FA => {
                    <i32>::sse_encode(3, serializer);
                }
                crate::api::api::DartLoginState::NeedsSMS2FAVerification(field0)
                    => {
                    <i32>::sse_encode(4, serializer);
                    <VerifyBody>::sse_encode(field0, serializer);
                }
                crate::api::api::DartLoginState::NeedsExtraStep(field0) => {
                    <i32>::sse_encode(5, serializer);
                    <String>::sse_encode(field0, serializer);
                }
                crate::api::api::DartLoginState::NeedsLogin => {
                    <i32>::sse_encode(6, serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartMessage::Message(field0) => {
                    <i32>::sse_encode(0, serializer);
                    <crate::api::api::DartNormalMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::RenameMessage(field0) => {
                    <i32>::sse_encode(1, serializer);
                    <crate::api::api::DartRenameMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::ChangeParticipants(field0) => {
                    <i32>::sse_encode(2, serializer);
                    <crate::api::api::DartChangeParticipantMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::React(field0) => {
                    <i32>::sse_encode(3, serializer);
                    <crate::api::api::DartReactMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::Delivered => {
                    <i32>::sse_encode(4, serializer);
                }
                crate::api::api::DartMessage::Read => {
                    <i32>::sse_encode(5, serializer);
                }
                crate::api::api::DartMessage::Typing => {
                    <i32>::sse_encode(6, serializer);
                }
                crate::api::api::DartMessage::Unsend(field0) => {
                    <i32>::sse_encode(7, serializer);
                    <crate::api::api::DartUnsendMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::Edit(field0) => {
                    <i32>::sse_encode(8, serializer);
                    <crate::api::api::DartEditMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::IconChange(field0) => {
                    <i32>::sse_encode(9, serializer);
                    <crate::api::api::DartIconChangeMessage>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessage::StopTyping => {
                    <i32>::sse_encode(10, serializer);
                }
                crate::api::api::DartMessage::EnableSmsActivation(field0) => {
                    <i32>::sse_encode(11, serializer);
                    <bool>::sse_encode(field0, serializer);
                }
                crate::api::api::DartMessage::MessageReadOnDevice => {
                    <i32>::sse_encode(12, serializer);
                }
                crate::api::api::DartMessage::SmsConfirmSent(field0) => {
                    <i32>::sse_encode(13, serializer);
                    <bool>::sse_encode(field0, serializer);
                }
                crate::api::api::DartMessage::MarkUnread => {
                    <i32>::sse_encode(14, serializer);
                }
                crate::api::api::DartMessage::PeerCacheInvalidate => {
                    <i32>::sse_encode(15, serializer);
                }
                crate::api::api::DartMessage::UpdateExtension(field0) => {
                    <i32>::sse_encode(16, serializer);
                    <crate::api::api::DartUpdateExtensionMessage>::sse_encode(field0,
                        serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartMessagePart {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartMessagePart::Text(field0) => {
                    <i32>::sse_encode(0, serializer);
                    <String>::sse_encode(field0, serializer);
                }
                crate::api::api::DartMessagePart::Attachment(field0) => {
                    <i32>::sse_encode(1, serializer);
                    <crate::api::api::DartAttachment>::sse_encode(field0,
                        serializer);
                }
                crate::api::api::DartMessagePart::Mention(field0, field1) => {
                    <i32>::sse_encode(2, serializer);
                    <String>::sse_encode(field0, serializer);
                    <String>::sse_encode(field1, serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartMessageParts {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Vec<crate::api::api::DartIndexedMessagePart>>::sse_encode(self.0,
                serializer);
        }
    }
    impl SseEncode for crate::api::api::DartMessageTarget {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartMessageTarget::Token(field0) => {
                    <i32>::sse_encode(0, serializer);
                    <Vec<u8>>::sse_encode(field0, serializer);
                }
                crate::api::api::DartMessageTarget::Uuid(field0) => {
                    <i32>::sse_encode(1, serializer);
                    <String>::sse_encode(field0, serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartMessageType {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartMessageType::IMessage => {
                    <i32>::sse_encode(0, serializer);
                }
                crate::api::api::DartMessageType::SMS {
                    is_phone, using_number, from_handle } => {
                    <i32>::sse_encode(1, serializer);
                    <bool>::sse_encode(is_phone, serializer);
                    <String>::sse_encode(using_number, serializer);
                    <Option<String>>::sse_encode(from_handle, serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartMMCSFile {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Vec<u8>>::sse_encode(self.signature, serializer);
            <String>::sse_encode(self.object, serializer);
            <String>::sse_encode(self.url, serializer);
            <Vec<u8>>::sse_encode(self.key, serializer);
            <usize>::sse_encode(self.size, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartNormalMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <crate::api::api::DartMessageParts>::sse_encode(self.parts,
                serializer);
            <Option<crate::api::api::DartBalloonBody>>::sse_encode(self.body,
                serializer);
            <Option<String>>::sse_encode(self.effect, serializer);
            <Option<String>>::sse_encode(self.reply_guid, serializer);
            <Option<String>>::sse_encode(self.reply_part, serializer);
            <crate::api::api::DartMessageType>::sse_encode(self.service,
                serializer);
        }
    }
    impl SseEncode for crate::api::api::DartPartExtension {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartPartExtension::Sticker {
                    msg_width,
                    rotation,
                    sai,
                    scale,
                    update,
                    sli,
                    normalized_x,
                    normalized_y,
                    version,
                    hash,
                    safi,
                    effect_type,
                    sticker_id } => {
                    <i32>::sse_encode(0, serializer);
                    <f64>::sse_encode(msg_width, serializer);
                    <f64>::sse_encode(rotation, serializer);
                    <u64>::sse_encode(sai, serializer);
                    <f64>::sse_encode(scale, serializer);
                    <Option<bool>>::sse_encode(update, serializer);
                    <u64>::sse_encode(sli, serializer);
                    <f64>::sse_encode(normalized_x, serializer);
                    <f64>::sse_encode(normalized_y, serializer);
                    <u64>::sse_encode(version, serializer);
                    <String>::sse_encode(hash, serializer);
                    <u64>::sse_encode(safi, serializer);
                    <i64>::sse_encode(effect_type, serializer);
                    <String>::sse_encode(sticker_id, serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartPrivateDeviceInfo {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Option<String>>::sse_encode(self.uuid, serializer);
            <Option<String>>::sse_encode(self.device_name, serializer);
            <Vec<u8>>::sse_encode(self.token, serializer);
            <bool>::sse_encode(self.is_hsa_trusted, serializer);
            <Vec<String>>::sse_encode(self.identites, serializer);
            <Vec<String>>::sse_encode(self.sub_services, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartReactMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.to_uuid, serializer);
            <u64>::sse_encode(self.to_part, serializer);
            <crate::api::api::DartReactMessageType>::sse_encode(self.reaction,
                serializer);
            <String>::sse_encode(self.to_text, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartReactMessageType {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartReactMessageType::React {
                    reaction, enable } => {
                    <i32>::sse_encode(0, serializer);
                    <crate::api::api::DartReaction>::sse_encode(reaction,
                        serializer);
                    <bool>::sse_encode(enable, serializer);
                }
                crate::api::api::DartReactMessageType::Extension { spec, body
                    } => {
                    <i32>::sse_encode(1, serializer);
                    <Value>::sse_encode(spec, serializer);
                    <crate::api::api::DartMessageParts>::sse_encode(body,
                        serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartReaction {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(match self {
                    crate::api::api::DartReaction::Heart => { 0 }
                    crate::api::api::DartReaction::Like => { 1 }
                    crate::api::api::DartReaction::Dislike => { 2 }
                    crate::api::api::DartReaction::Laugh => { 3 }
                    crate::api::api::DartReaction::Emphsize => { 4 }
                    crate::api::api::DartReaction::Question => { 5 }
                    _ => {
                        {
                            ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                    format_args!("")));
                        };
                    }
                }, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartRegisterState {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::DartRegisterState::Registered => {
                    <i32>::sse_encode(0, serializer);
                }
                crate::api::api::DartRegisterState::Registering => {
                    <i32>::sse_encode(1, serializer);
                }
                crate::api::api::DartRegisterState::Failed { retry_wait, error
                    } => {
                    <i32>::sse_encode(2, serializer);
                    <Option<u64>>::sse_encode(retry_wait, serializer);
                    <String>::sse_encode(error, serializer);
                }
            }
        }
    }
    impl SseEncode for crate::api::api::DartRenameMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.new_name, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartSupportAction {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.url, serializer);
            <String>::sse_encode(self.button, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartSupportAlert {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.title, serializer);
            <String>::sse_encode(self.body, serializer);
            <Option<crate::api::api::DartSupportAction>>::sse_encode(self.action,
                serializer);
        }
    }
    impl SseEncode for crate::api::api::DartTrustedPhoneNumber {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.number_with_dial_code, serializer);
            <String>::sse_encode(self.last_two_digits, serializer);
            <String>::sse_encode(self.push_mode, serializer);
            <u32>::sse_encode(self.id, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartUnsendMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.tuuid, serializer);
            <u64>::sse_encode(self.edit_part, serializer);
        }
    }
    impl SseEncode for crate::api::api::DartUpdateExtensionMessage {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <String>::sse_encode(self.for_uuid, serializer);
            <crate::api::api::DartPartExtension>::sse_encode(self.ext,
                serializer);
        }
    }
    impl SseEncode for f64 {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
        }
    }
    impl SseEncode for i32 {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
        }
    }
    impl SseEncode for i64 {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
        }
    }
    impl SseEncode for Vec<String> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(self.len() as _, serializer);
            for item in self { <String>::sse_encode(item, serializer); }
        }
    }
    impl SseEncode for Vec<crate::api::api::DartIndexedMessagePart> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(self.len() as _, serializer);
            for item in self {
                <crate::api::api::DartIndexedMessagePart>::sse_encode(item,
                    serializer);
            }
        }
    }
    impl SseEncode for Vec<crate::api::api::DartMessageTarget> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(self.len() as _, serializer);
            for item in self {
                <crate::api::api::DartMessageTarget>::sse_encode(item,
                    serializer);
            }
        }
    }
    impl SseEncode for Vec<crate::api::api::DartPrivateDeviceInfo> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(self.len() as _, serializer);
            for item in self {
                <crate::api::api::DartPrivateDeviceInfo>::sse_encode(item,
                    serializer);
            }
        }
    }
    impl SseEncode for Vec<crate::api::api::DartTrustedPhoneNumber> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(self.len() as _, serializer);
            for item in self {
                <crate::api::api::DartTrustedPhoneNumber>::sse_encode(item,
                    serializer);
            }
        }
    }
    impl SseEncode for Vec<u8> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(self.len() as _, serializer);
            for item in self { <u8>::sse_encode(item, serializer); }
        }
    }
    impl SseEncode for crate::api::api::MMCSTransferProgress {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <usize>::sse_encode(self.prog, serializer);
            <usize>::sse_encode(self.total, serializer);
            <Option<crate::api::api::DartMMCSFile>>::sse_encode(self.file,
                serializer);
        }
    }
    impl SseEncode for Option<String> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <String>::sse_encode(value, serializer);
                }
        }
    }
    impl SseEncode for Option<bool> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <bool>::sse_encode(value, serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartAttachment> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartAttachment>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartBalloonBody> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartBalloonBody>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartConversationData> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartConversationData>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartIMessage> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartIMessage>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartLoginState> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartLoginState>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartMMCSFile> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartMMCSFile>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartPartExtension> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartPartExtension>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartSupportAction> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartSupportAction>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<crate::api::api::DartSupportAlert> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <crate::api::api::DartSupportAlert>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for Option<u64> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <u64>::sse_encode(value, serializer);
                }
        }
    }
    impl SseEncode for Option<usize> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <usize>::sse_encode(value, serializer);
                }
        }
    }
    impl SseEncode for Option<Vec<crate::api::api::DartMessageTarget>> {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <bool>::sse_encode(self.is_some(), serializer);
            if let Some(value) = self {
                    <Vec<crate::api::api::DartMessageTarget>>::sse_encode(value,
                        serializer);
                }
        }
    }
    impl SseEncode for crate::api::api::PollResult {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            match self {
                crate::api::api::PollResult::Stop => {
                    <i32>::sse_encode(0, serializer);
                }
                crate::api::api::PollResult::Cont(field0) => {
                    <i32>::sse_encode(1, serializer);
                    <Option<crate::api::api::DartIMessage>>::sse_encode(field0,
                        serializer);
                }
            }
        }
    }
    impl SseEncode for
        (Vec<crate::api::api::DartTrustedPhoneNumber>,
        Option<crate::api::api::DartLoginState>) {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <Vec<crate::api::api::DartTrustedPhoneNumber>>::sse_encode(self.0,
                serializer);
            <Option<crate::api::api::DartLoginState>>::sse_encode(self.1,
                serializer);
        }
    }
    impl SseEncode for crate::api::api::RegistrationPhase {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <i32>::sse_encode(match self {
                    crate::api::api::RegistrationPhase::WantsOSConfig => { 0 }
                    crate::api::api::RegistrationPhase::WantsUserPass => { 1 }
                    crate::api::api::RegistrationPhase::WantsRegister => { 2 }
                    crate::api::api::RegistrationPhase::Registered => { 3 }
                    _ => {
                        {
                            ::core::panicking::panic_fmt(format_args!("not implemented: {0}",
                                    format_args!("")));
                        };
                    }
                }, serializer);
        }
    }
    impl SseEncode for crate::api::api::TransferProgress {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            <usize>::sse_encode(self.prog, serializer);
            <usize>::sse_encode(self.total, serializer);
            <Option<crate::api::api::DartAttachment>>::sse_encode(self.attachment,
                serializer);
        }
    }
    impl SseEncode for u32 {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
        }
    }
    impl SseEncode for u64 {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
        }
    }
    impl SseEncode for u8 {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_u8(self).unwrap();
        }
    }
    impl SseEncode for () {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {}
    }
    impl SseEncode for usize {
        fn sse_encode(self,
            serializer:
                &mut flutter_rust_bridge::for_generated::SseSerializer) {
            serializer.cursor.write_u64::<NativeEndian>(self as _).unwrap();
        }
    }
    #[cfg(not(target_family = "wasm"))]
    #[path = "frb_generated.io.rs"]
    mod io {
        use crate::api::api::*;
        use flutter_rust_bridge::{Handler, IntoIntoDart};
        use flutter_rust_bridge::for_generated::transform_result_dco;
        use flutter_rust_bridge::for_generated::byteorder::{
            NativeEndian, WriteBytesExt, ReadBytesExt,
        };
        use super::*;
        pub trait NewWithNullPtr {
            fn new_with_null_ptr()
            -> Self;
        }
        impl<T> NewWithNullPtr for *mut T {
            fn new_with_null_ptr() -> Self { std::ptr::null_mut() }
        }
        #[no_mangle]
        pub extern "C" fn frb_get_rust_content_hash() -> i32 {
            FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH
        }
        #[no_mangle]
        pub extern "C" fn frb_pde_ffi_dispatcher_primary(func_id: i32,
            port_: i64, ptr_: *mut u8, rust_vec_len_: i32, data_len_: i32) {
            pde_ffi_dispatcher_primary_impl(func_id, port_, ptr_,
                rust_vec_len_, data_len_)
        }
        #[no_mangle]
        pub extern "C" fn frb_pde_ffi_dispatcher_sync(func_id: i32,
            ptr_: *mut u8, rust_vec_len_: i32, data_len_: i32)
            -> ::flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
            pde_ffi_dispatcher_sync_impl(func_id, ptr_, rust_vec_len_,
                data_len_)
        }
        #[no_mangle]
        pub extern "C" fn dart_fn_deliver_output(call_id: i32, ptr_: *mut u8,
            rust_vec_len_: i32, data_len_: i32) {
            let message =
                unsafe {
                    ::flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_,
                        rust_vec_len_, data_len_)
                };
            FLUTTER_RUST_BRIDGE_HANDLER.dart_fn_handle_output(call_id,
                message)
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcPushState(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>::increment_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcPushState(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<PushState>>>::decrement_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMacOSConfig(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>::increment_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMacOSConfig(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MacOSConfig>>::decrement_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>::increment_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>::decrement_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVerifyBody(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>::increment_strong_count(ptr
                    as _);
        }
        #[no_mangle]
        pub extern "C" fn frbgen_bluebubbles_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVerifyBody(ptr:
                *const std::ffi::c_void) {
            MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyBody>>::decrement_strong_count(ptr
                    as _);
        }
    }
    #[cfg(not(target_family = "wasm"))]
    pub use io::*;
}
 stderr=warning: unreachable statement
   --> /home/tae/Documents/GitHub/apple-private-apis/omnisette/src/lib.rs:164:9
    |
159 | / ...   return Ok(AnisetteHeadersProviderRes::remote(Box::new(
160 | | ...       remote_anisette_v3::RemoteAnisetteProviderV3::new(configuration.anisette_url_v3, configuration.configuration_path.clone(), conf...
161 | | ...   )));
    | |_________- any code following this expression is unreachable
...
164 | / ...   return Ok(AnisetteHeadersProviderRes::remote(Box::new(
165 | | ...       remote_anisette::RemoteAnisetteProvider::new(configuration.anisette_url),
166 | | ...   )));
    | |__________^ unreachable statement
    |
    = note: `#[warn(unreachable_code)]` on by default
warning: unused import: `Proxy`
  --> /home/tae/Documents/GitHub/apple-private-apis/icloud-auth/src/client.rs:10:87
   |
10 |     header::{HeaderMap, HeaderName, HeaderValue}, Certificate, Client, ClientBuilder, Proxy, Response
   |                                                                                       ^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default
warning: unused import: `std::fmt::Display`
 --> /home/tae/Documents/GitHub/apple-private-apis/icloud-auth/src/lib.rs:3:5
  |
3 | use std::fmt::Display;
  |     ^^^^^^^^^^^^^^^^^
   Compiling rust_lib_bluebubbles v0.1.0 (/home/tae/Documents/GitHub/bb-app-restore/rust)
warning: unused import: `uuid::Uuid`
 --> /home/tae/Documents/GitHub/rustpush/src/ids/identity.rs:5:5
  |
5 | use uuid::Uuid;
  |     ^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default
warning: unused import: `base64_encode`
  --> /home/tae/Documents/GitHub/rustpush/src/imessage/messages.rs:16:144
   |
16 | ...ut_mmcs, Container, DataCacher, PreparedPut}, mmcsp, util::{base64_encode, decode_hex, encode_hex, gzip, plist_to_bin, ungzip}};
   |                                                                ^^^^^^^^^^^^^
warning: unused import: `sync::Arc`
 --> /home/tae/Documents/GitHub/rustpush/src/error.rs:1:15
  |
1 | use std::{io, sync::Arc};
  |               ^^^^^^^^^
warning: unused import: `tokio::runtime::Runtime`
 --> src/lib.rs:3:5
  |
3 | use tokio::runtime::Runtime;
  |     ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default
warning: unused import: `RwLock`
 --> src/native.rs:1:35
  |
1 | use std::{fmt::Debug, sync::{Arc, RwLock}};
  |                                   ^^^^^^
warning: unused imports: `Handle`, `Runtime`
 --> src/native.rs:3:22
  |
3 | use tokio::runtime::{Handle, Runtime};
  |                      ^^^^^^  ^^^^^^^
warning: unused imports: `InnerPushState`, `frb_generated::FLUTTER_RUST_BRIDGE_HANDLER`
 --> src/native.rs:6:62
  |
6 | ...ate, recv_wait, InnerPushState, PollResult, PushState, RegistrationPhase}, frb_generated::FLUTTER_RUST_BRIDGE_HANDLER, runtime};
  |                    ^^^^^^^^^^^^^^                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
warning: unused imports: `BorrowMut`, `Borrow`, `OnceLock`
 --> src/api/api.rs:3:20
  |
3 | use std::{borrow::{Borrow, BorrowMut}, future::Future, io::{Cursor, Write}, path::PathBuf, str::FromStr, sync::{Arc, OnceLock}, time::Dur...
  |                    ^^^^^^  ^^^^^^^^^                                                                                 ^^^^^^^^
warning: unused import: `IntoDart`
 --> src/api/api.rs:6:32
  |
6 | use flutter_rust_bridge::{frb, IntoDart, JoinHandle};
  |                                ^^^^^^^^
warning: unused import: `runtime::Runtime`
  --> src/api/api.rs:14:13
   |
14 | use tokio::{runtime::Runtime, select, sync::{oneshot::{self, Sender}, Mutex, RwLock}};
   |             ^^^^^^^^^^^^^^^^
warning: unused imports: `BalloonBody`, `MessagePart`
  --> src/api/api.rs:15:41
   |
15 | use rustpush::{init_logger, Attachment, BalloonBody, MMCSFile, MessagePart, MessageParts, OSConfig, RegisterState};
   |                                         ^^^^^^^^^^^            ^^^^^^^^^^^
warning: unused import: `HandleAlloc`
  --> src/api/api.rs:17:40
   |
17 | use uniffi::{deps::log::{info, error}, HandleAlloc};
   |                                        ^^^^^^^^^^^
    Finished dev [unoptimized + debuginfo] target(s) in 2.14s


[2024-05-11T19:31:35.633Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/crates.rs:26] parse manifest_path="/home/tae/Documents/GitHub/bb-app-restore/rust/Cargo.toml"
[2024-05-11T19:31:36.215Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs", module_path: ["crate"] }
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:150] parse_syn_item_mod module_path=["crate", "bbhwinfo"]
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:180] parse_syn_item_mod_contentful module_path=["crate", "bbhwinfo"]
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs", module_path: ["crate", "bbhwinfo"] }
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs", module_path: ["crate", "bbhwinfo"] }
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:150] parse_syn_item_mod module_path=["crate", "native"]
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:202] parse_syn_item_mod_contentless module_path=["crate", "native"]
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:205] file_path_candidates "native" "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs" ["/home/tae/Documents/GitHub/bb-app-restore/rust/src/native.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/native/mod.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib/native.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib/native/mod.rs"]
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/reader.rs:22] read_rust_file rust_file_path="/home/tae/Documents/GitHub/bb-app-restore/rust/src/native.rs" module=Some("native")
[2024-05-11T19:31:36.216Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/cargo_expand.rs:31] CachedCargoExpand execute manifest_dir= rust_crate_dir="/home/tae/Documents/GitHub/bb-app-restore/rust"
[2024-05-11T19:31:36.217Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:216] Trying to parse "/home/tae/Documents/GitHub/bb-app-restore/rust/src/native.rs"
[2024-05-11T19:31:36.230Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Inherited, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/native.rs", module_path: ["crate", "native"] }
[2024-05-11T19:31:36.231Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: UniFfiTraitVtableMsgReceiver, span: bytes(118438..118466) }
[2024-05-11T19:31:36.231Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: UniFFICallbackHandlerMsgReceiver, span: bytes(119733..119765) }
[2024-05-11T19:31:36.231Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: NativePushState, span: bytes(133034..133049) }
[2024-05-11T19:31:36.232Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Inherited, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/native.rs", module_path: ["crate", "native"] }
[2024-05-11T19:31:36.232Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:150] parse_syn_item_mod module_path=["crate", "api"]
[2024-05-11T19:31:36.233Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:202] parse_syn_item_mod_contentless module_path=["crate", "api"]
[2024-05-11T19:31:36.233Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:205] file_path_candidates "api" "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs" ["/home/tae/Documents/GitHub/bb-app-restore/rust/src/api.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib/api.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib/api/mod.rs"]
[2024-05-11T19:31:36.233Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/reader.rs:22] read_rust_file rust_file_path="/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs" module=Some("api")
[2024-05-11T19:31:36.233Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/cargo_expand.rs:31] CachedCargoExpand execute manifest_dir= rust_crate_dir="/home/tae/Documents/GitHub/bb-app-restore/rust"
[2024-05-11T19:31:36.235Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:216] Trying to parse "/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs"
[2024-05-11T19:31:36.274Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs", module_path: ["crate", "api"] }
[2024-05-11T19:31:36.274Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:150] parse_syn_item_mod module_path=["crate", "api", "api"]
[2024-05-11T19:31:36.274Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:180] parse_syn_item_mod_contentful module_path=["crate", "api", "api"]
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs", module_path: ["crate", "api", "api"] }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [], vis: Visibility::Public(Pub), type_token: Type, ident: Ident { sym: MyHandler, span: bytes(160335..160344) }, generics: Generics { lt_token: None, params: [], gt_token: None, where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: SimpleHandler, span: bytes(160359..160372) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: SimpleExecutor, span: bytes(160373..160387) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: NoOpErrorListener, span: bytes(160388..160405) }, arguments: PathArguments::None }] } }), Comma, GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: SimpleThreadPool, span: bytes(160407..160423) }, arguments: PathArguments::None }] } }), Comma, GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: MyAsyncRuntime, span: bytes(160437..160451) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } }), Comma, GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: NoOpErrorListener, span: bytes(160454..160471) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } }, semi_token: Semi }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: MyAsyncRuntime, span: bytes(160493..160507) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: FLUTTER_RUST_BRIDGE_HANDLER, span: bytes(161393..161420) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: SavedState, span: bytes(162613..162623) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: RegistrationPhase, span: bytes(176892..176909) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: InnerPushState, span: bytes(177046..177060) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: PushState, span: bytes(177413..177422) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartSupportAction, span: bytes(181663..181680) }
[2024-05-11T19:31:36.277Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartSupportAlert, span: bytes(181792..181808) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartHwExtra, span: bytes(186117..186128) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartDeviceInfo, span: bytes(186880..186894) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartBalloonBody, span: bytes(191655..191670) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartConversationData, span: bytes(191858..191878) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartLoginState, span: bytes(192173..192187) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartMMCSFile, span: bytes(192456..192468) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartAttachmentType, span: bytes(211500..211518) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartAttachment, span: bytes(219352..219366) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartMessagePart, span: bytes(241220..241235) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartPartExtension, span: bytes(241387..241404) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartIndexedMessagePart, span: bytes(241900..241922) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartMessageParts, span: bytes(242096..242112) }
[2024-05-11T19:31:36.278Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartMessageType, span: bytes(242416..242431) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartNormalMessage, span: bytes(244615..244632) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartRenameMessage, span: bytes(245091..245108) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartChangeParticipantMessage, span: bytes(245193..245221) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartReaction, span: bytes(245353..245365) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartReactMessageType, span: bytes(245562..245582) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartReactMessage, span: bytes(245846..245862) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartUnsendMessage, span: bytes(246057..246074) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartEditMessage, span: bytes(246188..246203) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartIconChangeMessage, span: bytes(246362..246383) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartUpdateExtensionMessage, span: bytes(246514..246540) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartMessage, span: bytes(246663..246674) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartMessageTarget, span: bytes(247334..247351) }
[2024-05-11T19:31:36.279Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartIMessage, span: bytes(247441..247453) }
[2024-05-11T19:31:36.280Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: PollResult, span: bytes(248753..248763) }
[2024-05-11T19:31:36.280Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: TransferProgress, span: bytes(260025..260041) }
[2024-05-11T19:31:36.280Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: MMCSTransferProgress, span: bytes(262610..262630) }
[2024-05-11T19:31:36.280Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartTrustedPhoneNumber, span: bytes(267410..267432) }
[2024-05-11T19:31:36.280Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartRegisterState, span: bytes(271243..271260) }
[2024-05-11T19:31:36.280Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: DartPrivateDeviceInfo, span: bytes(272806..272827) }
[2024-05-11T19:31:36.284Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs", module_path: ["crate", "api", "api"] }
[2024-05-11T19:31:36.289Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/api/mod.rs", module_path: ["crate", "api"] }
[2024-05-11T19:31:36.292Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:150] parse_syn_item_mod module_path=["crate", "frb_generated"]
[2024-05-11T19:31:36.292Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:202] parse_syn_item_mod_contentless module_path=["crate", "frb_generated"]
[2024-05-11T19:31:36.292Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:205] file_path_candidates "frb_generated" "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs" ["/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated/mod.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib/frb_generated.rs", "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib/frb_generated/mod.rs"]
[2024-05-11T19:31:36.292Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/reader.rs:22] read_rust_file rust_file_path="/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs" module=Some("frb_generated")
[2024-05-11T19:31:36.292Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/cargo_expand.rs:31] CachedCargoExpand execute manifest_dir= rust_crate_dir="/home/tae/Documents/GitHub/bb-app-restore/rust"
[2024-05-11T19:31:36.294Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:216] Trying to parse "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs"
[2024-05-11T19:31:36.379Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Inherited, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", module_path: ["crate", "frb_generated"] }
[2024-05-11T19:31:36.379Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: FrbWrapper, span: bytes(274125..274135) }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: MoiArc, span: bytes(274799..274805) }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [], vis: Visibility::Inherited, type_token: Type, ident: Ident { sym: ObjectId, span: bytes(278625..278633) }, generics: Generics { lt_token: None, params: [], gt_token: None, where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: usize, span: bytes(278636..278641) }, arguments: PathArguments::None }] } }, semi_token: Semi }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [], vis: Visibility::Public(Pub), type_token: Type, ident: Ident { sym: MoiArcPool, span: bytes(278656..278666) }, generics: Generics { lt_token: Some(Lt), params: [GenericParam::Type(TypeParam { attrs: [], ident: Ident { sym: T, span: bytes(278667..278668) }, colon_token: None, bounds: [], eq_token: None, default: None })], gt_token: Some(Gt), where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: std, span: bytes(278672..278675) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: sync, span: bytes(278677..278681) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: RwLock, span: bytes(278683..278689) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: MoiArcPoolInner, span: bytes(278690..278705) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(278706..278707) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } })], gt_token: Gt } }] } }, semi_token: Semi }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: MoiArcPoolInner, span: bytes(278726..278741) }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: IdGenerator, span: bytes(279034..279045) }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: MoiArcPoolValue, span: bytes(279618..279633) }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [Attribute { pound_token: Pound, style: AttrStyle::Outer, bracket_token: Bracket, meta: Meta::NameValue { path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: doc, span: bytes(280042..280083) }, arguments: PathArguments::None }] }, eq_token: Eq, value: Expr::Lit { attrs: [], lit: Lit::Str { token: " Please refer to `RustOpaque` for doc." } } } }], vis: Visibility::Public(Pub), type_token: Type, ident: Ident { sym: RustOpaqueMoi, span: bytes(280097..280110) }, generics: Generics { lt_token: Some(Lt), params: [GenericParam::Type(TypeParam { attrs: [], ident: Ident { sym: T, span: bytes(280111..280112) }, colon_token: None, bounds: [], eq_token: None, default: None })], gt_token: Some(Gt), where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: Some(PathSep), segments: [PathSegment { ident: Ident { sym: flutter_rust_bridge, span: bytes(280126..280145) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: for_generated, span: bytes(280147..280160) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: RustOpaqueBase, span: bytes(280162..280176) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(280177..280178) }, arguments: PathArguments::None }] } }), Comma, GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: MoiArc, span: bytes(280180..280186) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(280187..280188) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } })], gt_token: Gt } }] } }, semi_token: Semi }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [Attribute { pound_token: Pound, style: AttrStyle::Outer, bracket_token: Bracket, meta: Meta::NameValue { path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: doc, span: bytes(280196..280308) }, arguments: PathArguments::None }] }, eq_token: Eq, value: Expr::Lit { attrs: [], lit: Lit::Str { token: " A wrapper to support [arbitrary Rust types](https://cjycode.com/flutter_rust_bridge/guides/types/arbitrary)." } } } }], vis: Visibility::Public(Pub), type_token: Type, ident: Ident { sym: RustOpaque, span: bytes(280322..280332) }, generics: Generics { lt_token: Some(Lt), params: [GenericParam::Type(TypeParam { attrs: [], ident: Ident { sym: T, span: bytes(280333..280334) }, colon_token: None, bounds: [], eq_token: None, default: None })], gt_token: Some(Gt), where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: RustOpaqueMoi, span: bytes(280338..280351) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(280352..280353) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } }, semi_token: Semi }
[2024-05-11T19:31:36.380Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [Attribute { pound_token: Pound, style: AttrStyle::Outer, bracket_token: Bracket, meta: Meta::NameValue { path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: doc, span: bytes(280410..280455) }, arguments: PathArguments::None }] }, eq_token: Eq, value: Expr::Lit { attrs: [], lit: Lit::Str { token: " Please refer to `RustAutoOpaque` for doc." } } } }], vis: Visibility::Public(Pub), type_token: Type, ident: Ident { sym: RustAutoOpaqueMoi, span: bytes(280469..280486) }, generics: Generics { lt_token: Some(Lt), params: [GenericParam::Type(TypeParam { attrs: [], ident: Ident { sym: T, span: bytes(280487..280488) }, colon_token: None, bounds: [], eq_token: None, default: None })], gt_token: Some(Gt), where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: Some(PathSep), segments: [PathSegment { ident: Ident { sym: flutter_rust_bridge, span: bytes(280502..280521) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: for_generated, span: bytes(280523..280536) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: RustAutoOpaqueBase, span: bytes(280538..280556) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(280557..280558) }, arguments: PathArguments::None }] } }), Comma, GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: MoiArc, span: bytes(280568..280574) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: Some(PathSep), segments: [PathSegment { ident: Ident { sym: flutter_rust_bridge, span: bytes(280577..280596) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: for_generated, span: bytes(280598..280611) }, arguments: PathArguments::None }, PathSep, PathSegment { ident: Ident { sym: RustAutoOpaqueInner, span: bytes(280613..280632) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(280633..280634) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } })], gt_token: Gt } }] } })], gt_token: Gt } }] } }, semi_token: Semi }
[2024-05-11T19:31:36.381Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:124] parse_syn_item_struct_or_enum item_type=ItemType { attrs: [Attribute { pound_token: Pound, style: AttrStyle::Outer, bracket_token: Bracket, meta: Meta::NameValue { path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: doc, span: bytes(280643..280709) }, arguments: PathArguments::None }] }, eq_token: Eq, value: Expr::Lit { attrs: [], lit: Lit::Str { token: " Usually this is unneeded, and just write down arbitrary types." } } } }, Attribute { pound_token: Pound, style: AttrStyle::Outer, bracket_token: Bracket, meta: Meta::NameValue { path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: doc, span: bytes(280714..280794) }, arguments: PathArguments::None }] }, eq_token: Eq, value: Expr::Lit { attrs: [], lit: Lit::Str { token: " However, when you need arbitrary types at places that are not supported yet," } } } }, Attribute { pound_token: Pound, style: AttrStyle::Outer, bracket_token: Bracket, meta: Meta::NameValue { path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: doc, span: bytes(280799..280845) }, arguments: PathArguments::None }] }, eq_token: Eq, value: Expr::Lit { attrs: [], lit: Lit::Str { token: " use `RustOpaqueOpaque<YourArbitraryType>`." } } } }], vis: Visibility::Public(Pub), type_token: Type, ident: Ident { sym: RustAutoOpaque, span: bytes(280859..280873) }, generics: Generics { lt_token: Some(Lt), params: [GenericParam::Type(TypeParam { attrs: [], ident: Ident { sym: T, span: bytes(280874..280875) }, colon_token: None, bounds: [], eq_token: None, default: None })], gt_token: Some(Gt), where_clause: None }, eq_token: Eq, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: RustAutoOpaqueMoi, span: bytes(280879..280896) }, arguments: PathArguments::AngleBracketed { colon2_token: None, lt_token: Lt, args: [GenericArgument::Type(Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { sym: T, span: bytes(280897..280898) }, arguments: PathArguments::None }] } })], gt_token: Gt } }] } }, semi_token: Semi }
[2024-05-11T19:31:36.381Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:101] parse_syn_item_struct_or_enum item_ident=Ident { sym: StreamSink, span: bytes(282554..282564) }
[2024-05-11T19:31:36.381Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:150] parse_syn_item_mod module_path=["crate", "frb_generated", "io"]
[2024-05-11T19:31:36.381Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:180] parse_syn_item_mod_contentful module_path=["crate", "frb_generated", "io"]
[2024-05-11T19:31:36.381Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:31] parse START info=ModuleInfo { visibility: Inherited, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", module_path: ["crate", "frb_generated", "io"] }
[2024-05-11T19:31:36.381Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Inherited, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", module_path: ["crate", "frb_generated", "io"] }
[2024-05-11T19:31:36.390Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Inherited, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/frb_generated.rs", module_path: ["crate", "frb_generated"] }
[2024-05-11T19:31:36.394Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/source_graph/module_parser.rs:77] parse END info=ModuleInfo { visibility: Public, file_path: "/home/tae/Documents/GitHub/bb-app-restore/rust/src/lib.rs", module_path: ["crate"] }
[2024-05-11T19:31:36.403Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: new_push_state, span: bytes(18675..18689) }
[2024-05-11T19:31:36.404Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: service_from_ptr, span: bytes(19515..19531) }
[2024-05-11T19:31:36.404Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: register_ids, span: bytes(23156..23168) }
[2024-05-11T19:31:36.405Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: configure_macos, span: bytes(26918..26933) }
[2024-05-11T19:31:36.405Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: config_from_validation_data, span: bytes(27540..27567) }
[2024-05-11T19:31:36.405Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_device_info_state, span: bytes(28267..28288) }
[2024-05-11T19:31:36.405Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_device_info, span: bytes(28497..28512) }
[2024-05-11T19:31:36.406Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: config_from_encoded, span: bytes(30524..30543) }
[2024-05-11T19:31:36.406Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: ptr_to_dart, span: bytes(32016..32027) }
[2024-05-11T19:31:36.407Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: recv_wait, span: bytes(90025..90034) }
[2024-05-11T19:31:36.408Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: send, span: bytes(97832..97836) }
[2024-05-11T19:31:36.408Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_handles, span: bytes(98650..98661) }
[2024-05-11T19:31:36.408Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: do_reregister, span: bytes(99189..99202) }
[2024-05-11T19:31:36.409Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: new_msg, span: bytes(99728..99735) }
[2024-05-11T19:31:36.409Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: validate_targets, span: bytes(100457..100473) }
[2024-05-11T19:31:36.409Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_phase, span: bytes(101105..101114) }
[2024-05-11T19:31:36.409Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: download_attachment, span: bytes(101388..101407) }
[2024-05-11T19:31:36.410Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: download_mmcs, span: bytes(102794..102807) }
[2024-05-11T19:31:36.410Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: upload_mmcs, span: bytes(103969..103980) }
[2024-05-11T19:31:36.410Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: upload_attachment, span: bytes(105128..105145) }
[2024-05-11T19:31:36.411Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: try_auth, span: bytes(106373..106381) }
[2024-05-11T19:31:36.411Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: send_2fa_to_devices, span: bytes(107897..107916) }
[2024-05-11T19:31:36.411Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: verify_2fa, span: bytes(108246..108256) }
[2024-05-11T19:31:36.411Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_2fa_sms_opts, span: bytes(108816..108832) }
[2024-05-11T19:31:36.412Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: send_2fa_sms, span: bytes(109424..109436) }
[2024-05-11T19:31:36.412Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: verify_2fa_sms, span: bytes(109793..109807) }
[2024-05-11T19:31:36.412Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: reset_state, span: bytes(110219..110230) }
[2024-05-11T19:31:36.413Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: invalidate_id_cache, span: bytes(111172..111191) }
[2024-05-11T19:31:36.413Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_user_name, span: bytes(112044..112057) }
[2024-05-11T19:31:36.413Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_regstate, span: bytes(112653..112665) }
[2024-05-11T19:31:36.413Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: convert_token_to_uuid, span: bytes(113638..113659) }
[2024-05-11T19:31:36.414Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_sms_targets, span: bytes(114299..114314) }
[2024-05-11T19:31:36.414Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: save, span: bytes(81809..81813) }
[2024-05-11T19:31:36.414Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: restore, span: bytes(81885..81892) }
[2024-05-11T19:31:36.414Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: get_size, span: bytes(82029..82037) }
[2024-05-11T19:31:36.414Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/codegen/parser/function_parser/mod.rs:70] parse_function function name: Ident { sym: as_plain, span: bytes(83516..83524) }
[2024-05-11T19:31:36.578Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:22] Guessing toolchain the runner is run into
[2024-05-11T19:31:36.589Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:71] Checking presence of freezed in dev_dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:31:36.591Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:103] Checking presence of freezed in dev_dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:31:36.601Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:71] Checking presence of freezed_annotation in dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:31:36.602Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:103] Checking presence of freezed_annotation in dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:31:36.611Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:71] Checking presence of build_runner in dev_dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:31:36.613Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:103] Checking presence of build_runner in dev_dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:31:36.624Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/dart_build_runner.rs:12] Running build_runner at dart_root="/home/tae/Documents/GitHub/bb-app-restore"
[2024-05-11T19:31:36.624Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:22] Guessing toolchain the runner is run into
[2024-05-11T19:31:36.636Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:129] execute command: bin=sh args="-c \"flutter\" \"pub\" \"run\" \"build_runner\" \"build\" \"--delete-conflicting-outputs\" \"--enable-experiment=class-modifiers\"" current_dir=Some("/home/tae/Documents/GitHub/bb-app-restore") cmd=cd "/home/tae/Documents/GitHub/bb-app-restore" && FRB_SIMPLE_BUILD_SKIP="1" "sh" "-c" "\"flutter\" \"pub\" \"run\" \"build_runner\" \"build\" \"--delete-conflicting-outputs\" \"--enable-experiment=class-modifiers\""
[2024-05-11T19:34:06.916Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:140] command=cd "/home/tae/Documents/GitHub/bb-app-restore" && FRB_SIMPLE_BUILD_SKIP="1" "sh" "-c" "\"flutter\" \"pub\" \"run\" \"build_runner\" \"build\" \"--delete-conflicting-outputs\" \"--enable-experiment=class-modifiers\"" stdout=[INFO] Generating build script...
[INFO] Generating build script completed, took 1.2s

[WARNING] Attempting to enable experiments `[class-modifiers]`, but the current SDK
language version does not match your `analyzer` package language version:

Analyzer language version: 3.2.0
SDK language version: 3.3.0

In order to use experiments you may need to upgrade or downgrade your
`analyzer` package dependency such that its language version matches that of
your current SDK, see https://github.com/dart-lang/build/issues/2685.

Note that you may or may not have a direct dependency on the `analyzer`
package in your `pubspec.yaml`, so you may have to add that. You can see your
current version by running `pub deps`.

[INFO] Initializing inputs
[INFO] Reading cached asset graph...
[INFO] Reading cached asset graph completed, took 1.4s

[INFO] Checking for updates since last build...
[INFO] Checking for updates since last build completed, took 6.8s

[INFO] Running build...
[INFO] 1.0s elapsed, 0/16 actions completed.
[INFO] 2.1s elapsed, 0/16 actions completed.
[INFO] 3.1s elapsed, 0/16 actions completed.
[WARNING] objectbox_generator:resolver on lib/app/animations/balloon_rendering.dart:
Your current `analyzer` version may not fully support your current SDK version.

Analyzer language version: 3.2.0
SDK language version: 3.3.0

Please update to the latest `analyzer` version (6.5.0) by running
`flutter packages upgrade`.

If you are not getting the latest version by running the above command, you
can try adding a constraint like the following to your pubspec to start
diagnosing why you can't get the latest version:

dev_dependencies:
  analyzer: ^6.5.0

[INFO] 4.5s elapsed, 0/16 actions completed.
[INFO] 5.5s elapsed, 0/16 actions completed.
[INFO] 6.5s elapsed, 0/16 actions completed.
[INFO] 7.7s elapsed, 0/16 actions completed.
[INFO] 8.8s elapsed, 0/53 actions completed.
[INFO] 9.8s elapsed, 0/53 actions completed.
[INFO] 10.9s elapsed, 0/65 actions completed.
[INFO] 11.9s elapsed, 16/65 actions completed.
[INFO] 13.1s elapsed, 16/65 actions completed.
[INFO] 14.1s elapsed, 17/72 actions completed.
[INFO] 15.2s elapsed, 18/72 actions completed.
[INFO] 16.2s elapsed, 23/266 actions completed.
[INFO] 17.3s elapsed, 52/266 actions completed.
[INFO] 18.3s elapsed, 64/273 actions completed.
[INFO] 19.4s elapsed, 195/382 actions completed.
[INFO] 20.5s elapsed, 329/607 actions completed.
[INFO] 21.6s elapsed, 483/763 actions completed.
[INFO] 22.7s elapsed, 682/890 actions completed.
[INFO] 1m 18s elapsed, 850/978 actions completed.
[WARNING] No actions completed for 55.2s, waiting on:
  - build_resolvers:transitive_digests on package:pointycastle/src/ec_standard_curve_constructor.dart
  - build_resolvers:transitive_digests on package:pointycastle/src/impl/base_asymmetric_block_cipher.dart
  - build_resolvers:transitive_digests on package:pointycastle/src/impl/keccak_engine.dart
  - build_resolvers:transitive_digests on package:pointycastle/src/impl/base_digest.dart
  - build_resolvers:transitive_digests on package:pointycastle/src/impl/base_key_derivator.dart
  .. and 123 more

[INFO] 1m 19s elapsed, 953/1030 actions completed.
[INFO] 1m 20s elapsed, 1018/1073 actions completed.
[INFO] 1m 21s elapsed, 1093/1137 actions completed.
[INFO] 1m 25s elapsed, 1121/1142 actions completed.
[INFO] 1m 26s elapsed, 1127/1148 actions completed.
[INFO] 1m 27s elapsed, 1132/1153 actions completed.
[INFO] 1m 28s elapsed, 1147/1164 actions completed.
[INFO] 1m 29s elapsed, 1159/1176 actions completed.
[INFO] 1m 30s elapsed, 1168/1186 actions completed.
[INFO] 1m 31s elapsed, 1179/1196 actions completed.
[INFO] 1m 32s elapsed, 1191/1208 actions completed.
[INFO] 1m 33s elapsed, 1203/1220 actions completed.
[INFO] 1m 35s elapsed, 1213/1230 actions completed.
[INFO] 1m 36s elapsed, 1228/1245 actions completed.
[INFO] 1m 37s elapsed, 1239/1256 actions completed.
[INFO] 1m 38s elapsed, 1257/1274 actions completed.
[INFO] 1m 39s elapsed, 1274/1291 actions completed.
[INFO] 1m 40s elapsed, 1291/1309 actions completed.
[INFO] 1m 42s elapsed, 1309/1326 actions completed.
[INFO] 1m 43s elapsed, 1323/1340 actions completed.
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:entity Contact(0:0) sync:OFF
[WARNING] objectbox_generator:resolver on lib/models/io/contact.dart:
  Skipping property 'structuredName': type 'StructuredName?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  Skipping property 'initials': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  Skipping property 'hashCode': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property dbId(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property id(0:0) type:string flags:2048 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property displayName(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property phones(0:0) type:stringVector flags:0
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property emails(0:0) type:stringVector flags:0
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property avatar(0:0) type:byteVector flags:0
[INFO] objectbox_generator:resolver on lib/models/io/contact.dart:  property dbStructuredName(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:entity FCMData(0:0) sync:OFF
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  Skipping property 'isNull': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property projectID(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property storageBucket(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property apiKey(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property firebaseURL(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property clientID(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/fcm_data.dart:  property applicationID(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:entity ThemeStruct(0:0) sync:OFF
[WARNING] objectbox_generator:resolver on lib/models/io/theme.dart:
  Skipping property 'data': type 'ThemeData' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  Skipping property 'isPreset': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  Skipping property 'colorDescriptions': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  Skipping property 'textSizes': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  Skipping property 'defaultTextSizes': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  Skipping property 'hashCode': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  property name(0:0) type:string flags:2080 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  property gradientBg(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  property googleFont(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme.dart:  property dbThemeData(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:entity ThemeEntry(0:0) sync:OFF
[WARNING] objectbox_generator:resolver on lib/models/io/theme_entry.dart:
  Skipping property 'color': type 'Color?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  Skipping property 'style': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property themeId(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property name(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property isFont(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property fontSize(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property fontWeight(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property themeObjectId(0:0) type:relation flags:520 index:value relTarget: ThemeObject
[INFO] objectbox_generator:resolver on lib/models/io/theme_entry.dart:  property dbColor(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:entity ThemeObject(0:0) sync:OFF
[WARNING] objectbox_generator:resolver on lib/models/io/theme_object.dart:
  Skipping property 'data': type 'ThemeData?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/theme_object.dart:
  Skipping property 'entries': type 'List<ThemeEntry>' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  relation backlink themeEntries from ThemeEntry.themeObject
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  Skipping property 'isPreset': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  Skipping property 'themeData': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  Skipping property 'hashCode': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property name(0:0) type:string flags:2080 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property selectedLightTheme(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property selectedDarkTheme(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property gradientBg(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property previousLightTheme(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/theme_object.dart:  property previousDarkTheme(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:entity Attachment(0:0) sync:OFF
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'bytes': annotated with @Transient.
[WARNING] objectbox_generator:resolver on lib/models/io/attachment.dart:
  Skipping property 'metadata': type 'Map<String, dynamic>?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'hasValidSize': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'aspectRatio': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'mimeStart': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'baseDirectory': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'directory': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'path': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'convertedPath': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'existsOnDisk': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'existsOnDiskAsync': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property 'canCompress': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  Skipping property '_isPortrait': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property originalROWID(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property guid(0:0) type:string flags:2080 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property uti(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property mimeType(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property isOutgoing(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property transferName(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property totalBytes(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property height(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property width(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property webUrl(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property hasLivePhoto(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property messageId(0:0) type:relation flags:520 index:value relTarget: Message
[INFO] objectbox_generator:resolver on lib/models/io/attachment.dart:  property dbMetadata(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:entity Handle(0:0) sync:OFF
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property 'fakeName': annotated with @Transient.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property '_color': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property 'webContact': annotated with @Transient.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property 'contact': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property 'displayName': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property 'initials': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  Skipping property 'hashCode': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property originalROWID(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property uniqueAddressAndService(0:0) type:string flags:2080 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property address(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property formattedAddress(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property service(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property country(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property defaultEmail(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property defaultPhone(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property contactRelationId(0:0) type:relation flags:520 index:value relTarget: Contact
[INFO] objectbox_generator:resolver on lib/models/io/handle.dart:  property color(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:entity Chat(0:0) sync:OFF
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property '_participants': is private.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property '_latestMessage': is private.
[WARNING] objectbox_generator:resolver on lib/models/io/chat.dart:
  DateTime property 'dbOnlyLatestMessageDate' in entity 'Chat' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[WARNING] objectbox_generator:resolver on lib/models/io/chat.dart:
  DateTime property 'dateDeleted' in entity 'Chat' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property '_customAvatarPath': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property '_pinIndex': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  standalone relation handles(0:0) relTarget: Handle(null)
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  relation backlink messages from Message.chat
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property 'properTitle': is read-only/getter.
[WARNING] objectbox_generator:resolver on lib/models/io/chat.dart:
  Skipping property 'participants': type 'List<Handle>' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/chat.dart:
  Skipping property 'latestMessage': type 'Message' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property 'dbLatestMessage': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property 'isTextForwarding': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property 'isSMS': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property 'isIMessage': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  Skipping property 'isGroup': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property guid(0:0) type:string flags:2080 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property chatIdentifier(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property isArchived(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property muteType(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property muteArgs(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property isPinned(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property hasUnreadMessage(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property title(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property apnTitle(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property displayName(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property autoSendReadReceipts(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property autoSendTypingIndicators(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property textFieldText(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property textFieldAttachments(0:0) type:stringVector flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property dbOnlyLatestMessageDate(0:526293286661780207) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property dateDeleted(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property style(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property lockChatName(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property lockChatIcon(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property lastReadMessageGuid(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property groupVersion(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property guidRefs(0:0) type:stringVector flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property usingHandle(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property isRpSms(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property telephonyId(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property customAvatarPath(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/chat.dart:  property pinIndex(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:entity Message(0:0) sync:OFF
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  DateTime property 'dateCreated' in entity 'Message' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  DateTime property 'datePlayed' in entity 'Message' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'handle': type 'Handle?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  DateTime property 'dateDeleted' in entity 'Message' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'metadata': type 'Map<String, dynamic>?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'attachments': type 'List<Attachment?>' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'associatedMessages': type 'List<Message>' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'attributedBody': type 'List<AttributedBody>' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'messageSummaryInfo': type 'List<MessageSummaryInfo>' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  Skipping property 'payloadData': type 'PayloadData?' not supported, consider creating a relation for @Entity types (https://docs.objectbox.io/relations), or replace with getter/setter converting to a supported type (https://docs.objectbox.io/advanced/custom-types).
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property '_error': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property '_dateRead': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property '_dateDelivered': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property '_dateEdited': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  relation backlink dbAttachments from Attachment.message
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  DateTime property 'dateRead' in entity 'Message' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  DateTime property 'dateDelivered' in entity 'Message' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[WARNING] objectbox_generator:resolver on lib/models/io/message.dart:
  DateTime property 'dateEdited' in entity 'Message' is stored and read using millisecond precision. To silence this warning, add an explicit type using @Property(type: PropertyType.date) or @Property(type: PropertyType.dateNano) annotation.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'fullText': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'isLegacyUrlPreview': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'url': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'isInteractive': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'interactiveText': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'interactiveMediaPath': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'isGroupEvent': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'groupEventText': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'isParticipantEvent': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'isBigEmoji': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'realAttachments': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'previewAttachments': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'reactions': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'indicatorToShow': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  Skipping property 'normalizedThreadPart': is read-only/getter.
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property id(0:0) type:long flags:1
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property originalROWID(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property guid(0:0) type:string flags:2080 index:hash
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property handleId(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property otherHandle(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property text(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property subject(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property country(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dateCreated(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property isFromMe(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property hasDdResults(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property datePlayed(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property itemType(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property groupTitle(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property groupActionType(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property balloonBundleId(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property associatedMessageGuid(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property associatedMessagePart(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property associatedMessageType(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property expressiveSendStyleId(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property hasAttachments(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property hasReactions(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dateDeleted(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property threadOriginatorGuid(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property threadOriginatorPart(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property bigEmoji(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property hasApplePayloadData(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property wasDeliveredQuietly(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property didNotifyRecipient(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property isBookmarked(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property hasBeenForwarded(0:0) type:bool flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property stagingGuid(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property chatId(0:0) type:relation flags:520 index:value relTarget: Chat
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property error(0:0) type:long flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dateRead(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dateDelivered(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dateEdited(0:0) type:date flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dbAttributedBody(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dbMessageSummaryInfo(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dbPayloadData(0:0) type:string flags:0
[INFO] objectbox_generator:resolver on lib/models/io/message.dart:  property dbMetadata(0:0) type:string flags:0
[INFO] 1m 45s elapsed, 1355/1370 actions completed.
[INFO] 1m 55s elapsed, 1355/1371 actions completed.
[INFO] 2m 2s elapsed, 1355/1371 actions completed.
[WARNING] No actions completed for 17.2s, waiting on:
  - objectbox_generator:resolver on lib/app/animations/love_rendering.dart
  - objectbox_generator:resolver on lib/app/components/avatars/contact_avatar_widget.dart
  - objectbox_generator:resolver on lib/app/components/custom/custom_bouncing_scroll_physics.dart
  - objectbox_generator:resolver on lib/app/components/custom_text_editing_controllers.dart
  - objectbox_generator:resolver on lib/services/backend/sync/tasks/sync_tasks.dart
  .. and 11 more

[INFO] 2m 4s elapsed, 1369/1384 actions completed.
[INFO] 2m 5s elapsed, 1386/1386 actions completed.
[INFO] 2m 6s elapsed, 1387/1401 actions completed.
[INFO] 2m 7s elapsed, 1397/1401 actions completed.
[INFO] Running build completed, took 2m 8s

[INFO] Caching finalized dependency graph...
[INFO] Caching finalized dependency graph completed, took 807ms

[INFO] Succeeded after 2m 9s with 1131 outputs (2523 actions)

 stderr=
[2024-05-11T19:34:06.917Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/format_dart.rs:13] execute format_dart paths=["lib/src/rust/api/api.dart", "lib/src/rust/frb_generated.dart", "lib/src/rust/frb_generated.io.dart", "lib/src/rust/frb_generated.web.dart"] line_length=80
[2024-05-11T19:34:06.917Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:129] execute command: bin=sh args="-c \"dart\" \"format\" \"--line-length\" \"80\" \"lib/src/rust/api/api.dart\" \"lib/src/rust/frb_generated.dart\" \"lib/src/rust/frb_generated.io.dart\" \"lib/src/rust/frb_generated.web.dart\"" current_dir=Some("/home/tae/Documents/GitHub/bb-app-restore") cmd=cd "/home/tae/Documents/GitHub/bb-app-restore" && "sh" "-c" "\"dart\" \"format\" \"--line-length\" \"80\" \"lib/src/rust/api/api.dart\" \"lib/src/rust/frb_generated.dart\" \"lib/src/rust/frb_generated.io.dart\" \"lib/src/rust/frb_generated.web.dart\""
[2024-05-11T19:34:08.945Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:140] command=cd "/home/tae/Documents/GitHub/bb-app-restore" && "sh" "-c" "\"dart\" \"format\" \"--line-length\" \"80\" \"lib/src/rust/api/api.dart\" \"lib/src/rust/frb_generated.dart\" \"lib/src/rust/frb_generated.io.dart\" \"lib/src/rust/frb_generated.web.dart\"" stdout=Formatted lib/src/rust/api/api.dart
Formatted lib/src/rust/frb_generated.dart
Formatted lib/src/rust/frb_generated.io.dart
Formatted lib/src/rust/frb_generated.web.dart
Formatted 4 files (4 changed) in 1.74 seconds.
 stderr=
[2024-05-11T19:34:08.946Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/format_rust.rs:9] execute format_rust paths=["src/frb_generated.rs", "src/frb_generated.io.rs", "src/frb_generated.web.rs"]
[2024-05-11T19:34:08.946Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:129] execute command: bin=sh args="-c \"rustfmt\" \"--edition\" \"2018\" \"src/frb_generated.rs\" \"src/frb_generated.io.rs\" \"src/frb_generated.web.rs\"" current_dir=Some("/home/tae/Documents/GitHub/bb-app-restore/rust") cmd=cd "/home/tae/Documents/GitHub/bb-app-restore/rust" && "sh" "-c" "\"rustfmt\" \"--edition\" \"2018\" \"src/frb_generated.rs\" \"src/frb_generated.io.rs\" \"src/frb_generated.web.rs\""
[2024-05-11T19:34:09.215Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/commands/command_runner.rs:140] command=cd "/home/tae/Documents/GitHub/bb-app-restore/rust" && "sh" "-c" "\"rustfmt\" \"--edition\" \"2018\" \"src/frb_generated.rs\" \"src/frb_generated.io.rs\" \"src/frb_generated.web.rs\"" stdout= stderr=
[2024-05-11T19:34:09.218Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:22] Guessing toolchain the runner is run into
[2024-05-11T19:34:09.232Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:71] Checking presence of flutter_rust_bridge in dependencies at /home/tae/Documents/GitHub/bb-app-restore
[2024-05-11T19:34:09.234Z DEBUG /home/tae/.cargo/registry/src/index.crates.io-6f17d22bba15001f/flutter_rust_bridge_codegen-2.0.0-dev.33/src/library/utils/dart_repository/dart_repo.rs:103] Checking presence of flutter_rust_bridge in dependencies at /home/tae/Documents/GitHub/bb-app-restore
Done!
